<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pteros: Core functionality</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pteros.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pteros
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Molecular modeling library for human beings!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('core.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Core functionality </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#basic_classes">Basic classes</a><ul><li class="level2"><a href="#atoms">Atom</a></li>
<li class="level2"><a href="#system">System</a></li>
<li class="level2"><a href="#frame">Frame</a></li>
<li class="level2"><a href="#selection">Selection</a></li>
</ul>
</li>
<li class="level1"><a href="#load">Loading molecular system</a><ul><li class="level2"><a href="#formats">Supported file formats</a></li>
<li class="level2"><a href="#types_of_info">What is loaded from data files?</a></li>
<li class="level2"><a href="#simple_load">Simple loading</a></li>
<li class="level2"><a href="#advanced_load">Advanced loading with file handlers</a></li>
<li class="level2"><a href="#load_callback">Loading with callback</a></li>
<li class="level2"><a href="#load_filters">Using input filters</a></li>
</ul>
</li>
<li class="level1"><a href="#making_selections">Selecting atoms</a><ul><li class="level2"><a href="#sel_methods">Ways of creating selections</a></li>
<li class="level2"><a href="#sel_args">Arguments of selection methods</a></li>
<li class="level2"><a href="#sel_modify">Modifying selections</a></li>
<li class="level2"><a href="#all_sel">Selecting everything</a></li>
<li class="level2"><a href="#sel_lang">Selection language</a><ul><li class="level3"><a href="#select_all">Selecting everything</a></li>
<li class="level3"><a href="#keyword_sel">Keyword selections</a></li>
<li class="level3"><a href="#num_prop">Numeric properties</a></li>
<li class="level3"><a href="#num_expr">Numeric expressions</a></li>
<li class="level3"><a href="#num_comp">Numeric comparisons</a></li>
<li class="level3"><a href="#log_expr">Logical expressions</a></li>
<li class="level3"><a href="#within_sel">Within selections</a></li>
<li class="level3"><a href="#by_res">By residue selections</a></li>
<li class="level3"><a href="#dist_sel">Distance selections</a></li>
</ul>
</li>
<li class="level2"><a href="#text_based_sel">Text-based and coordinate-depensent selections</a></li>
<li class="level2"><a href="#subsel">Sub-selections</a></li>
<li class="level2"><a href="#sel_comb">Combining selections</a></li>
</ul>
</li>
<li class="level1"><a href="#access">Accessing properties of selected atoms</a><ul><li class="level2"><a href="#cpp_access">Accessor methods in C++</a></li>
<li class="level2"><a href="#py_access">Accessor methods in Python</a></li>
<li class="level2"><a href="#indexing">Indexing operator of Selection object</a></li>
<li class="level2"><a href="#sel_iter">Iterating over selected atoms</a></li>
<li class="level2"><a href="#uniform_prop">Getting particular property of all selected atoms</a></li>
</ul>
</li>
<li class="level1"><a href="#sys_build">Building molecular systems</a><ul><li class="level2"><a href="#atom_add_del">Adding and deleting atoms</a></li>
<li class="level2"><a href="#append_remove">Appending and removing systems and selections</a></li>
<li class="level2"><a href="#distib">Multiplying selections</a></li>
<li class="level2"><a href="#rearrange">Rearranging atoms</a></li>
</ul>
</li>
<li class="level1"><a href="#pbc">Working with periodicity</a><ul><li class="level2"><a href="#pbc_get_set">Getting, setting and modifying periodic box</a></li>
<li class="level2"><a href="#wrap">Wrapping and unwrapping</a></li>
<li class="level2"><a href="#pbc_measure">Periodic distances and closest images</a></li>
</ul>
</li>
<li class="level1"><a href="#dist_search">Fast distance search and spatial grids</a><ul><li class="level2"><a href="#dist_search_variants">Different forms of distance search</a><ul><li class="level3"><a href="#search_1_sel">Searching contacts within single selection</a></li>
<li class="level3"><a href="#search_2_sel">Searching contacts between two selections</a></li>
<li class="level3"><a href="#search_within">Searching around given selection</a></li>
<li class="level3"><a href="#repeated_search">Repeated searching around multiple targets</a></li>
</ul>
</li>
<li class="level2"><a href="#custom_grid">Custom spatial grids</a></li>
</ul>
</li>
<li class="level1"><a href="#energy">Evaluating non-bond energies</a><ul><li class="level2"><a href="#get_en">Computing non-bond energies</a></li>
</ul>
</li>
<li class="level1"><a href="#dssp">Secondary structure of proteins</a></li>
<li class="level1"><a href="#measure_sasa">Solvent accessible surface area</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="basic_classes"></a>
Basic classes</h1>
<h2><a class="anchor" id="atoms"></a>
Atom</h2>
<p>Pteros treats all particles as atoms. There is no destinction between real atoms and various dummy particles (virtual sites, shell particles, etc.). Each atom in Pteros has the following attributes:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Property </th><th class="markdownTableHeadNone">Data type </th><th class="markdownTableHeadNone">Description </th><th class="markdownTableHeadNone">Comment  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">Atom name </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">resid </td><td class="markdownTableBodyNone">integer </td><td class="markdownTableBodyNone">Residue id </td><td class="markdownTableBodyNone">Unique within single protein or nucleic acid chain. May start at any value defined in the structure file for each chain.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">resindex </td><td class="markdownTableBodyNone">integer </td><td class="markdownTableBodyNone">Residue index </td><td class="markdownTableBodyNone">Unique within the whole system. Chain boundaries are ignored. Starts at 0. Assigned automatically.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">resname </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">Residue name </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">chain </td><td class="markdownTableBodyNone">char </td><td class="markdownTableBodyNone">Chain identifier </td><td class="markdownTableBodyNone">Single character. If no chain information is present defaults to single space.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tag </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">Arbitrary textual tag </td><td class="markdownTableBodyNone">Defaults to empty string  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mass </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Atomic mass </td><td class="markdownTableBodyNone">In atomic units. If not given explicitly in the structure file guessed from the atom name. Defaults to 1.0.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">charge </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">Atomic charge </td><td class="markdownTableBodyNone">Electron charge units. Defaults to 0.0. Usually read from topology files.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">beta </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">PDB B-factor </td><td class="markdownTableBodyNone">Defaults to 0.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">occupancy </td><td class="markdownTableBodyNone">float </td><td class="markdownTableBodyNone">PDB occupancy facor </td><td class="markdownTableBodyNone">Defaults to 0.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">integer </td><td class="markdownTableBodyNone">Numerical index of atom type </td><td class="markdownTableBodyNone">Defaults to -1, only makes sense in MD topologies.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">type_name </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">Name of atom type </td><td class="markdownTableBodyNone">Defaults to empty string.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">element_number </td><td class="markdownTableBodyNone">interger </td><td class="markdownTableBodyNone">Atomic number of the atom </td><td class="markdownTableBodyNone">Defaults to -1. If not defined in the structure or topology file it is not guessed. Element name is not stored and is computed from element number on the fly if needed.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Coordinates of atoms are stored separately in <a class="el" href="core.html#frame">frames</a>.</dd></dl>
<p>Atoms are represented by the objects of <a class="el" href="classpteros_1_1Atom.html" title="Class which represents a single atom.">Atom</a> class.</p>
<h2><a class="anchor" id="system"></a>
System</h2>
<p>The system is a container for atoms, coordinate frames and associated force field parameters. The system may contain many coordinate frames which represent different states of the system (MD time steps or NMR structures for example). <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> is usually read from one or more structure, trajectory or topology files. Systems are represented by the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> class.</p>
<dl class="section note"><dt>Note</dt><dd>The system is <em>not</em> a representation of particular data file! Although attributes of atoms are similar to the fields of PDB files the system is much more general concept. The system could be constructed from a single file (such as PDB), from several files (such as PDB+XTC) or could be built from scratch programmatically by adding individual atoms and frames.</dd></dl>
<h2><a class="anchor" id="frame"></a>
Frame</h2>
<p>The frame is representation of the instanteneous state of the system. It contains coordinates of all atoms, time stamp and the periodic box (if the periodic boundary conditions are used). Represented by the <a class="el" href="structpteros_1_1Frame.html" title="Definition of single trajectory frame.">Frame</a> class.</p>
<h2><a class="anchor" id="selection"></a>
Selection</h2>
<p><a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> is a subset of atoms from particular system. <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> <em>do not contain any data</em> but just points to existing atoms in the system. <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> should be considered as a "handle" to certain group of atoms which allows to query their properties and to manipulate their attributes and coordinates in various ways.</p>
<h1><a class="anchor" id="load"></a>
Loading molecular system</h1>
<h2><a class="anchor" id="formats"></a>
Supported file formats</h2>
<p>Currently the following file formats are supported:</p><ul>
<li>Structure files<ul>
<li>PDB</li>
<li>GRO</li>
<li>MOL2</li>
</ul>
</li>
<li>Trajectories<ul>
<li>XTC</li>
<li>TRR</li>
<li>TNG <dl class="section note"><dt>Note</dt><dd>TNG files also contain structure information.</dd></dl>
</li>
<li>DCD</li>
</ul>
</li>
<li>Topology<ul>
<li>TPR <dl class="section note"><dt>Note</dt><dd>Read only. Produced by Gromacs.</dd></dl>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="types_of_info"></a>
What is loaded from data files?</h2>
<p>Molecular data formats contain different information about the system. In Pteros all information stored in the data files is classified into <em>atoms</em>, <em>coordinates</em>, <em>trajectory</em> and <em>topology</em>. Type of particular piece of information is determined by Mol_file_content class. </p><dl class="section user"><dt>Atoms</dt><dd>Set by <code>Mol_file_content::atoms()</code>. Information about atoms in the system (name, residue name, chain and other attributes) but without coordinates. </dd></dl>
<dl class="section user"><dt>Coordinates</dt><dd>Set by <code>Mol_file_content::coord()</code>. Single set of coordinates of atoms (single frame) and the periodic box if periodicity is present. </dd></dl>
<dl class="section user"><dt>Trajectory</dt><dd>Set by<code>Mol_file_content::traj()</code>. The number of coordinate frames each containing a set of coordinates, time stamp and the periodic box if periodicity is present. </dd></dl>
<dl class="section user"><dt>Topology</dt><dd>Set by <code>Mol_file_content::top()</code>. MD topology containing connectivity, atom types, precise masses, partial charges, non-bond Van-der-Waals parameters, etc.</dd></dl>
<p>Particular file format may contain different information. For example PDB files contain atoms and coordinates. XTC files contain the trajectory but no atoms. TNG files contain atoms and trajectory at the same time, etc. There are two ways of loading data files - simple and advanced.</p>
<p>Loading is performed by either constructor of the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> class or by <a class="el" href="classpteros_1_1System.html#ad57c63ce4503f6b7ba0afcb6e8159aad" title="Read structure, trajectory or topology from file.">System::load()</a> method. In both cases the same behavior and parameters are used.</p>
<h2><a class="anchor" id="simple_load"></a>
Simple loading</h2>
<p>When the data file is loaded in Pteros using simple mode the information being loaded depend on the file type and on the current content of the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> where the data go. The most "logical" way of adding new data to the system is chosen but there is no fine control about what is read and how. Here is an example:</p>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// (1) Initial loading in constructor</span></div>
<div class="line">System s(<span class="stringliteral">&quot;somefile.pdb&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (2) Adding structure file</span></div>
<div class="line">s.load(<span class="stringliteral">&quot;other-file.pdb&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (3) Adding trajectory</span></div>
<div class="line">s.load(<span class="stringliteral">&quot;trajectory.xtc&quot;</span>,3,20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (4) Adding topology</span></div>
<div class="line">s.load(<span class="stringliteral">&quot;topol.tpr&quot;</span>);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Initial loading in constructor</span></div>
<div class="line">s = System(<span class="stringliteral">&#39;somefile.pdb&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># (2) Adding structure file</span></div>
<div class="line">s.load(<span class="stringliteral">&#39;other-file.pdb&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># (3) Adding trajectory</span></div>
<div class="line">s.load(<span class="stringliteral">&#39;trajectory.xtc&#39;</span>,3,20)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># (4) Adding topology</span></div>
<div class="line">s.load(<span class="stringliteral">&#39;topol.tpr&#39;</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<ol type="1">
<li>In this example we first construct the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> from the PDB file "somefile.pdb". File type is <em>always</em> determined by extension. Since on step (1) the system is empty all possible information is read from this file, which means that atoms and coordinates would be read.</li>
<li>On step (2) we are adding another PDB file "other-file.pdb". Now the system already contains atoms and one coordinate frame, thus Pteros deduces that we just want to <em>add</em> another coordinate frame. Thus only coordinates are read from "other-file.pdb". If the number of atoms in this file is the same as in the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> another frame is added. No check is performed if "other-file.pdb" actually contains the same set of atoms as the system - everything with matching number of atoms is accepted.</li>
<li>On step (3) we are adding an XTC trajectory. The logic is the same as on step (2) - the number of new coordinate frames are added to the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a>. Additional arguments instruct Pteros to read frames from 3 to 20 inclusive.</li>
<li>Finally on step (4) we are adding topology file. Since the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> already contain atoms only additional topological information (like atom types, charges, connectivity, etc.) is read.</li>
</ol>
<p>Since different file types contain different information the logic of adding information to the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> becomes rather complicated in non-trivial situations. The following table summarises what is read from different files in different cases.</p>
<p><b>Initial loading (in constructor or to the empty <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a>)</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File type </th><th class="markdownTableHeadNone">What is loaded? </th><th class="markdownTableHeadNone">Comment  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PDB, GRO, MOL2 </td><td class="markdownTableBodyNone">Atoms and the single frame </td><td class="markdownTableBodyNone">MOL2 does not contain periodic box!  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TPR </td><td class="markdownTableBodyNone">Atoms, the single frame, full topology </td><td class="markdownTableBodyNone">Read only. The file itself should be produced by Gromacs  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TNG </td><td class="markdownTableBodyNone">Atoms and multiple frames </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">XTC, TRR, DCD </td><td class="markdownTableBodyNone">Fails and raises exception </td><td class="markdownTableBodyNone">In Pteros reading trajectory into an empty system is not allowed (in contrast to VMD for example).  </td></tr>
</table>
<p><b>Adding data to the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> which is not empty (by <a class="el" href="classpteros_1_1System.html#ad57c63ce4503f6b7ba0afcb6e8159aad" title="Read structure, trajectory or topology from file.">System::load()</a>)</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File type </th><th class="markdownTableHeadNone">What is loaded? </th><th class="markdownTableHeadNone">Comment  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PDB, GRO, MOL2 </td><td class="markdownTableBodyNone">Single frame </td><td class="markdownTableBodyNone">New frame added. The only check is matching number of atoms.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TPR </td><td class="markdownTableBodyNone">Topology </td><td class="markdownTableBodyNone">Adds atom types and charges, updates masses, adds other topology information. No coordinates are read, no frames added.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TNG, XTC, TRR, DCD </td><td class="markdownTableBodyNone">Multiple frames </td><td class="markdownTableBodyNone">Adds number of new frames. The only check is matching number of atoms.  </td></tr>
</table>
<h2><a class="anchor" id="advanced_load"></a>
Advanced loading with file handlers</h2>
<dl class="section warning"><dt>Warning</dt><dd>Advanced mode should only be used in specific cases and only if you are absolutely sure that you need fine control. The simple mode is the most convenient in most practical scenarios.</dd>
<dd>
Advanced mode and file handlers are <em>not</em> available from Python.</dd></dl>
<p>In advanced mode the user specifies explicitly what to read and what to store in the system.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;pteros/core/mol_file.h&quot;</span></div>
<div class="line">...</div>
<div class="line">auto pdb_handler = Mol_file::open(<span class="stringliteral">&quot;some-pdb-file.pdb&quot;</span>,<span class="charliteral">&#39;r&#39;</span>);</div>
<div class="line"><span class="keyword">auto</span> gro_handler = Mol_file::open(<span class="stringliteral">&quot;some-gro-file.gro&quot;</span>,<span class="charliteral">&#39;r&#39;</span>);</div>
<div class="line"><span class="keyword">auto</span> xtc_handler = Mol_file::open(<span class="stringliteral">&quot;some-xtc-file.xtc&quot;</span>,<span class="charliteral">&#39;r&#39;</span>);</div>
<div class="line"> </div>
<div class="line">System s;</div>
<div class="line">s.load(pdb_handler, Mol_file_content().atoms(<span class="keyword">true</span>)); <span class="comment">// (1)</span></div>
<div class="line">s.load(gro_handler, Mol_file_content().traj(<span class="keyword">true</span>)); <span class="comment">// (2)</span></div>
<div class="line"><span class="comment">// Load frames until the end of trajectory one by one</span></div>
<div class="line"><span class="keywordtype">bool</span> ok;</div>
<div class="line"><span class="keyword">auto</span> c = Mol_file_content();</div>
<div class="line">c.traj(<span class="keyword">true</span>);</div>
<div class="line"><span class="keywordflow">do</span> {</div>
<div class="line">    ok = s.load(xtc_handler, c); <span class="comment">// (3)</span></div>
<div class="line">} <span class="keywordflow">while</span>(ok);</div>
</div><!-- fragment --><p>In this example we first create three file handlers for corresponding PDB, GRO and XTC files. File handlers are created by static Mol_file::open() method. Handlers could be created for reading (mode 'r') and for writing (mode 'w'). In our case we open them for reading. After that we create an empty system and load data from handlers.</p>
<ol type="1">
<li>On step (1) we read only atoms from PDB file. No coordinates are read.</li>
<li>On step (2) we add coordinates rom GRO file.</li>
<li>On step (3) we read frames from XTC file one by one in the loop up to the end of trajectory. The load() method returns false on failure to read next frame, which allows to track the end of trajectory.</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>Behavior of Mol_file_content().traj(true) for file handlers is different from what is used in simple mode! Each call of <code>System::load(handler)</code> reads the <em>single</em> frame. This behavior is intentional and allows reading frames one by one. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If one will use <code>Mol_file_content().atoms(true).traj(true)</code> or "Mol_file_content().coord(true).traj(true)" on steps (1) and (2) then trajectory reading will be ignored. This is again intentional to separate frame-by-frame trajectory reading from reading other information. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <code>Mol_file_content().atoms(true)</code> is specified the system is cleared before reading even if it already contained some atoms!</dd></dl>
<h2><a class="anchor" id="load_callback"></a>
Loading with callback</h2>
<p>Both simple and advanced forms of <a class="el" href="classpteros_1_1System.html#ad57c63ce4503f6b7ba0afcb6e8159aad" title="Read structure, trajectory or topology from file.">System::load()</a> support optional user-defined callback function as last parameter. This function takes two argiments: the pointer to parent system and the index of current frame. If the callback returns true the loading of trajctory will continue to the next frame. If it returns false the loading will stop. Such callbacks are useful for organizing simple frame by frame processing of trajectories.</p>
<dl class="section note"><dt>Note</dt><dd>Trajectory_processor class and analysis plugins provide much more powerful way of trajectory processing. Callbacks are the most useful as "quick and dirty" way of doing this in simple scripts.</dd></dl>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keywordtype">bool</span> callback(System* sys, <span class="keywordtype">int</span> frame){</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Called for frame &quot;</span> &lt;&lt; frame &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">System sys(<span class="stringliteral">&#39;some-structure.pdb&#39;</span>);</div>
<div class="line">sys.load(<span class="stringliteral">&#39;some-traj.xtc&#39;</span>,0,-1,0,&amp;callback)</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="keyword">def </span>callback(sys,frame):</div>
<div class="line">    <span class="keywordflow">print</span> <span class="stringliteral">&#39;Called for frame &#39;</span>,frame</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">sys = System(<span class="stringliteral">&#39;some-structure.pdb&#39;</span>)</div>
<div class="line">sys.load(<span class="stringliteral">&#39;some-traj.xtc&#39;</span>, on_frame=callback)</div>
</div><!-- fragment --> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>When using callback the frames are still accumulated by the system. If you want to store only one frame in the memory use this trick: <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keywordtype">bool</span> callback(System* sys, <span class="keywordtype">int</span> frame){</div>
<div class="line">    <span class="comment">// Do the job in callback</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// Delete current frame.</span></div>
<div class="line">    sys-&gt;frame_delete(frame,frame);</div>
<div class="line">}</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="keyword">def </span>callback(sys,frame):</div>
<div class="line">    <span class="comment"># Do the job in callback</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="comment"># Delete current frame.</span></div>
<div class="line">    sys.frame_delete(frame,frame)</div>
</div><!-- fragment --> </td></tr>
</table>
Please note that this is done by default by analysis plugins.</dd></dl>
<h2><a class="anchor" id="load_filters"></a>
Using input filters</h2>
<p>Sometimes it is not necessary to read all atoms from the data file. For example if the system contains protein in water quite often only the protein is of interest. However, water may constitute 75% of the whole number of atoms and storing them in the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> is redundant. This is especially important if many frames have to be kept in memory. In this case filtering the input may save huge amount of memory.</p>
<p>Pteros has the mechanism of input filtering which helps in such situations. The filter is a special kind of <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> which is set to empty system <em>before</em> any loading occures. All subsequent calls to <a class="el" href="classpteros_1_1System.html#ad57c63ce4503f6b7ba0afcb6e8159aad" title="Read structure, trajectory or topology from file.">System::load()</a> will be filtered and only selected atoms will be kept in the system.</p>
<p>Filter is set by <a class="el" href="classpteros_1_1System.html#a85c84a9212616a8922271ff2b69f5048" title="Filters narrow set of atoms and coordinates which are loaded from data files.">System::set_filter()</a> method. It takes the same <a class="el" href="core.html#sel_args">arguments</a> as ordinary selections with two exceptions: filters can't be coordinate-dependent (they will throw an error during loading) and can't be set by callbacs.</p>
<dl class="section note"><dt>Note</dt><dd>Filters do not make loading faster. In fact it becomes slower (up to 2 times for very large frames) and consumes twise as much memory <em>during</em> loading. However, when loading finishes the system will contain only selected atoms. If many frames are stored overall memory consumption will be much smaller. <em>Do not use filters if loading speed is critical!</em></dd></dl>
<p>Filter could only be set to empty system (set_filter() throws an error otherwise), thus the correct way of using them is the following: </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Create empty system</span></div>
<div class="line">System sys;</div>
<div class="line"><span class="comment">// Set filter</span></div>
<div class="line">sys.set_filter(<span class="stringliteral">&quot;name CA&quot;</span>);</div>
<div class="line"><span class="comment">// All calls to load will use filter now</span></div>
<div class="line">sys.load(<span class="stringliteral">&quot;some_protein.pdb&quot;</span>);</div>
<div class="line">sys.load(<span class="stringliteral">&quot;trajectory.xtc&quot;</span>);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Create empty system</span></div>
<div class="line">sys = System()</div>
<div class="line"><span class="comment"># Set filter</span></div>
<div class="line">sys.set_filter(<span class="stringliteral">&#39;name CA&#39;</span>)</div>
<div class="line"><span class="comment"># All calls to load will use filter now</span></div>
<div class="line">sys.load(<span class="stringliteral">&#39;some_protein.pdb&#39;</span>)</div>
<div class="line">sys.load(<span class="stringliteral">&#39;trajectory.xtc&#39;</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>Filters could not be used for topologies! load() throws an error if attempting to load topology with filter.</dd></dl>
<h1><a class="anchor" id="making_selections"></a>
Selecting atoms</h1>
<p>Selections are the most important objects in Pteros which allow manipulating groups of atoms in the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a>. It is important to understand that selections do not contain any data but merely point to the set of atoms in the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a>.</p>
<h2><a class="anchor" id="sel_methods"></a>
Ways of creating selections</h2>
<p>In order to select atoms one need to create <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> class in one of the following ways:</p>
<ol type="1">
<li><b> Direct construction of <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> object</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">Selection sel(system, &lt;arguments...&gt;);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sel = Selection(system, &lt;arguments...&gt;)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b> Construction by System::select() method</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">Selection sel = system.<a class="code" href="classpteros_1_1Selection.html#ae34b009075510a23700132e477c2f5fe">select</a>(&lt;arguments...&gt;);</div>
<div class="line"><span class="comment">// Or using type inference:</span></div>
<div class="line"><span class="keyword">auto</span> sel = system.<a class="code" href="classpteros_1_1Selection.html#ae34b009075510a23700132e477c2f5fe">select</a>(&lt;arguments...&gt;);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sel = system.select(&lt;arguments...&gt;)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b> Construction by System::operator()</b> This is exactly the same as the previous one but less verbose. <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">Selection sel = system(&lt;arguments...&gt;);</div>
<div class="line"><span class="comment">// Or using type inference:</span></div>
<div class="line"><span class="keyword">auto</span> sel = system(&lt;arguments...&gt;);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sel = system(&lt;arguments...&gt;)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
</ol>
<h2><a class="anchor" id="sel_args"></a>
Arguments of selection methods</h2>
<p>The arguments passed to selection could be the following (only method 2 is used for illustration but any method takes the same variants of arguments):</p>
<ol type="1">
<li><b>Textual selections (using <a class="el" href="core.html#sel_lang">selection language</a>)</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Defaults to 1st frame in the System</span></div>
<div class="line"><span class="keyword">auto</span> sel = system.<a class="code" href="classpteros_1_1Selection.html#ae34b009075510a23700132e477c2f5fe">select</a>(<span class="stringliteral">&quot;resname ALA GLY and within 3.0 pbc of resid 23-34 45&quot;</span>);</div>
<div class="line"><span class="comment">// Explicitly points to frame #3</span></div>
<div class="line"><span class="keyword">auto</span> sel = system.<a class="code" href="classpteros_1_1Selection.html#ae34b009075510a23700132e477c2f5fe">select</a>(<span class="stringliteral">&quot;resname ALA GLY and within 3.0 pbc of resid 23-34 45&quot;</span>, 3);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Defaults to 1st frame in the System</span></div>
<div class="line">sel = system.select(<span class="stringliteral">&#39;resname ALA GLY and within 3.0 pbc of resid 23-34 45&#39;</span>)</div>
<div class="line"><span class="comment"># Explicitly points to frame #3</span></div>
<div class="line">sel = system.select(<span class="stringliteral">&#39;resname ALA GLY and within 3.0 pbc of resid 23-34 45&#39;</span>, 3)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b>Pair of atom indexes</b> Selects atoms with indexes in the given range (inclusive). <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keywordtype">int</span> ind1 = 10;</div>
<div class="line"><span class="keywordtype">int</span> ind2 = 20;</div>
<div class="line">sel = system.<a class="code" href="classpteros_1_1Selection.html#ae34b009075510a23700132e477c2f5fe">select</a>(ind1, ind2);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">ind1 = 10</div>
<div class="line">ind2 = 20</div>
<div class="line">sel = system.select(ind1, ind2)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b>Vector of atom indexes</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">vector&lt;int&gt; ind = {1,2,3,56,67,100};</div>
<div class="line">sel = system.<a class="code" href="classpteros_1_1Selection.html#ae34b009075510a23700132e477c2f5fe">select</a>(ind);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">ind = [1,2,3,56,67,100]</div>
<div class="line">sel = system.select(ind)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b>Pair of iterators to integer vector</b> <dl class="section warning"><dt>Warning</dt><dd>This is only available in C++.</dd></dl>
<div class="fragment"><div class="line">vector&lt;int&gt; ind = {5,10,34,1,4,15};</div>
<div class="line">Selection sel21(sys,ind.begin(),ind.end());</div>
</div><!-- fragment --></li>
<li><b>Custom callback function</b> This method allows implementing arbitrary complex logic of selecting atoms by delegating the work to user-provided callback function. The callback function has the following signature: <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keywordtype">void</span> selection_callback(<span class="keyword">const</span> System&amp; sys, <span class="keywordtype">int</span> fr, std::vector&lt;int&gt;&amp; ind);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="keyword">def </span>selection_callback(sys, fr, ind)</div>
</div><!-- fragment --> </td></tr>
</table>
First argument is the parent <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a>, second - is the target frame, and the third is integer vector, which have to be filled with indexes of selected atoms. The following example shows selecting atoms with x&gt;5. On practice this is easier to implement using textual selections but callback allows implementing arbitrarily complex logic. <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Callback function</span></div>
<div class="line"><span class="keywordtype">void</span> sel_func(<span class="keyword">const</span> System&amp; sys,<span class="keywordtype">int</span> fr,std::vector&lt;int&gt;&amp; ind){</div>
<div class="line">    <span class="comment">// Just for example we are selecting all atoms with x&gt;5</span></div>
<div class="line">    ind.clear();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;sys.num_atoms();++i)</div>
<div class="line">        <span class="keywordflow">if</span>(sys.XYZ(i,fr)(0)&gt;5.0) ind.push_back(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">System s(<span class="stringliteral">&quot;struct.pdb&quot;</span>);</div>
<div class="line"><span class="comment">// Callback function is called to fill selection</span></div>
<div class="line">Selection sel(s, &amp;sel_func);</div>
<div class="line"><span class="comment">// The same but for specific frame #3</span></div>
<div class="line">Selection sel(s, &amp;sel_func, 3);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Callback function</span></div>
<div class="line">def sel_func(sys,fr,ind):</div>
<div class="line">    <span class="comment"># Just for example we are selecting all atoms with x&gt;5</span></div>
<div class="line">    ind = []</div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(sys.num_atoms()):</div>
<div class="line">        <span class="keywordflow">if</span> sys.getXYZ(i,fr)[0]&gt;5.0:</div>
<div class="line">            ind.append(i)</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">s = System(<span class="stringliteral">&#39;struct.pdb&#39;</span>)</div>
<div class="line"><span class="comment"># Callback function is called to fill selection</span></div>
<div class="line">sel = s.select(sel_func)</div>
<div class="line"><span class="comment"># The same but for specific frame #3</span></div>
<div class="line">sel = s.select(sel_func, 3)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
</ol>
<h2><a class="anchor" id="sel_modify"></a>
Modifying selections</h2>
<p>Existing selection objects could be modified in two ways: by changing parent <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> and by selecting another set of atoms. Parent selection is changed by <a class="el" href="classpteros_1_1Selection.html#a0671ecf29f52dd438a5870dd44314c87" title="Sets new system for selection.">Selection::set_system()</a> method:</p>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">System sys1(<span class="stringliteral">&quot;structure1.pdb&quot;</span>);</div>
<div class="line">System sys2(<span class="stringliteral">&quot;structure2.pdb&quot;</span>);</div>
<div class="line"><span class="comment">// Create empty selection pointing to sys1</span></div>
<div class="line">Selection sel(sys1);</div>
<div class="line"><span class="comment">// Make it point to sys2</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#a0671ecf29f52dd438a5870dd44314c87">set_system</a>(sys2);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sys1 = System(<span class="stringliteral">&#39;structure1.pdb&#39;</span>)</div>
<div class="line">sys2 = System(<span class="stringliteral">&#39;structure2.pdb&#39;</span>)</div>
<div class="line"><span class="comment"># Create empty selection pointing to sys1</span></div>
<div class="line">sel = Selection(sys1)</div>
<div class="line"><span class="comment"># Make it point to sys2</span></div>
<div class="line">sel.set_system(sys2)</div>
</div><!-- fragment --> </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classpteros_1_1Selection.html#a0671ecf29f52dd438a5870dd44314c87" title="Sets new system for selection.">Selection::set_system()</a> always clears content of selection and leaves it empty even if it contained some data!</dd></dl>
<p>In order to modify content of seelction (the set of selected atoms) the number of <a class="el" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40" title="Modifies selection string in existing selection.">Selection::modify()</a> methods is present. They accept the same arguments as corresponding constructors of <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> class. Each method also have the variant where new <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> is passed as the first argument:</p>
<ol type="1">
<li><b>Textual selections</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Changes selected atoms</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(<span class="stringliteral">&quot;resname ALA GLY&quot;</span>);</div>
<div class="line"><span class="comment">// The same but also assigns to other system</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(other_system, <span class="stringliteral">&quot;resname ALA GLY&quot;</span>);</div>
<div class="line"><span class="comment">// The same but also changes the target frame to frame 3</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(other_system, <span class="stringliteral">&quot;resname ALA GLY&quot;</span>, 3);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Changes selected atoms</span></div>
<div class="line">sel.modify(<span class="stringliteral">&#39;resname ALA GLY&#39;</span>)</div>
<div class="line"><span class="comment"># The same but also assigns to other system</span></div>
<div class="line">sel.modify(other_system, <span class="stringliteral">&#39;resname ALA GLY&#39;</span>)</div>
<div class="line"><span class="comment"># The same but also changes the target frame to frame 3</span></div>
<div class="line">sel.modify(other_system, <span class="stringliteral">&#39;resname ALA GLY&#39;</span>, 3)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b>Pair of atom indexes</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keywordtype">int</span> ind1 = 10;</div>
<div class="line"><span class="keywordtype">int</span> ind2 = 20;</div>
<div class="line"><span class="comment">// Changes selected atoms</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(ind1, ind2);</div>
<div class="line"><span class="comment">// The same but also assigns to other system</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(other_system, ind1, ind2);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">ind1 = 10</div>
<div class="line">ind2 = 20</div>
<div class="line"><span class="comment"># Changes selected atoms</span></div>
<div class="line">sel.modify(ind1, ind2)</div>
<div class="line"><span class="comment"># The same but also assigns to other system</span></div>
<div class="line">sel.modify(other_system, ind1, ind2)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b>Vector of atom indexes</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">vector&lt;int&gt; ind = {1,2,3,56,67,100};</div>
<div class="line"><span class="comment">// Changes selected atoms</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(ind);</div>
<div class="line"><span class="comment">// The same but also assigns to other system</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(other_system, ind);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">ind = [1,2,3,56,67,100]</div>
<div class="line"><span class="comment"># Changes selected atoms</span></div>
<div class="line">sel.modify(ind)</div>
<div class="line"><span class="comment"># The same but also assigns to other system</span></div>
<div class="line">sel.modify(other_system, ind)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
<li><b>Pair of iterators to integer vector</b> <dl class="section warning"><dt>Warning</dt><dd>This is only available in C++.</dd></dl>
<div class="fragment"><div class="line">vector&lt;int&gt; ind = {5,10,34,1,4,15};</div>
<div class="line"><span class="comment">// Changes selected atoms</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(ind.begin(),ind.end());</div>
<div class="line"><span class="comment">// The same but also assigns to other system</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(other_system, ind.begin(),ind.end());</div>
</div><!-- fragment --></li>
<li><b>Custom callback function</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Callback function</span></div>
<div class="line"><span class="keywordtype">void</span> sel_func(<span class="keyword">const</span> System&amp; sys,<span class="keywordtype">int</span> fr,std::vector&lt;int&gt;&amp; ind){</div>
<div class="line">    <span class="comment">// Just for example we are selecting all atoms with x&gt;5</span></div>
<div class="line">    ind.clear();</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;sys.num_atoms();++i)</div>
<div class="line">        <span class="keywordflow">if</span>(sys.x(i,fr)&gt;5.0) ind.push_back(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Changes selected atoms</span></div>
<div class="line">sel.modify(sel_func);</div>
<div class="line"><span class="comment">// The same but also assigns to other system</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(other_system, sel_func);</div>
<div class="line"><span class="comment">// The same but also changes the target frame to frame 3</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">modify</a>(other_system, sel_func, 3);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Callback function</span></div>
<div class="line"><span class="keyword">def </span>sel_func(sys,fr,ind):</div>
<div class="line">    <span class="comment"># Just for example we are selecting all atoms with x&gt;5</span></div>
<div class="line">    ind = []</div>
<div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(sys.num_atoms()):</div>
<div class="line">        <span class="keywordflow">if</span> sys[i,fr].x&gt;5.0:</div>
<div class="line">            ind.append(i)</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Changes selected atoms</span></div>
<div class="line">sel.modify(sel_func)</div>
<div class="line"><span class="comment"># The same but also assigns to other system</span></div>
<div class="line">sel.modify(other_system, sel_func)</div>
<div class="line"><span class="comment"># The same but also changes the target frame to frame 3</span></div>
<div class="line">sel.modify(other_system, sel_func, 3)</div>
</div><!-- fragment --> </td></tr>
</table>
</li>
</ol>
<h2><a class="anchor" id="all_sel"></a>
Selecting everything</h2>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Using System::select_all() (the most efficient method)</span></div>
<div class="line">Selection all = system.select_all();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using operator &quot;()&quot; with no arguments (the same as above)</span></div>
<div class="line">all = system();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using textual selection (less efficient)</span></div>
<div class="line">all = Selection(<span class="stringliteral">&quot;all&quot;</span>);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Using System.select_all() (the most efficient method)</span></div>
<div class="line">all = system.select_all()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Using operator &quot;()&quot; with no arguments (the same as above)</span></div>
<div class="line">all = system()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Using textual selection (less efficient)</span></div>
<div class="line">all = Selection(<span class="stringliteral">&#39;all&#39;</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<h2><a class="anchor" id="sel_lang"></a>
Selection language</h2>
<p>Selection language in Pteros is similar but not identical to one of <a href="http://www.ks.uiuc.edu/Research/vmd/vmd-1.3/ug/node132.html">VMD</a>. Simple selections could be copy-pasted from VMD to Pteros and vice versa, while more complex selections would be different. Particularly Pteros provides much more advanced selections which include periodic boundary conditions, which are not possible in VMD.</p>
<p>The basic elements of selection language are the following:</p>
<h3><a class="anchor" id="select_all"></a>
Selecting everything</h3>
<p>The keyword "all" selects all atoms in the system.</p>
<h3><a class="anchor" id="keyword_sel"></a>
Keyword selections</h3>
<p>Consist of the keyword, which represent property of the atom, followed by one or more values of this property. The values are implicitly combined by logical OR. Depending on the keyword the values are either strings, integers or unsigned integers.</p>
<p>For integers in addition to individual values the ranges are allowed in two forms: <code>1 to 10</code> and <code>1-10</code>. Both forms are equivalent.</p>
<p>For strings regular expressions could be given in single ('') or double ("") quotes. The systnax of the regular expressions is the same <a href="http://www.cplusplus.com/reference/regex/ECMAScript/">as used in C++11</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Keyword </th><th class="markdownTableHeadNone">Type of values </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">name CA CB "C.*"  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">resname </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">resname ALA GLU '.N.*'  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">resid </td><td class="markdownTableBodyNone">int </td><td class="markdownTableBodyNone">resid 1 2 3 4-10 20 to 40  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">resindex </td><td class="markdownTableBodyNone">unsigned int </td><td class="markdownTableBodyNone">resindex 1 2 3 5 to 100 200-211  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">chain </td><td class="markdownTableBodyNone">single character </td><td class="markdownTableBodyNone">chain A B C  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tag </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">tag TAG1 TAG2  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">index </td><td class="markdownTableBodyNone">unsigned int </td><td class="markdownTableBodyNone">index 12 13 45 2-7  </td></tr>
</table>
<h3><a class="anchor" id="num_prop"></a>
Numeric properties</h3>
<p>Consist of a lone keyword, which represent single numeric property of the atom. Numeric properties could be either integer or floats. They could be combined to <a class="el" href="core.html#num_expr">numerical expressions</a> and compared by <a class="el" href="core.html#num_comp">numeric comparisons</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Keyword </th><th class="markdownTableHeadNone">Property  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">x </td><td class="markdownTableBodyNone">X coordinate of the atom  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">y </td><td class="markdownTableBodyNone">Y coordinate of the atom  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">z </td><td class="markdownTableBodyNone">Z coordinate of the atom  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">beta </td><td class="markdownTableBodyNone">B-factor of the atom  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">occupancy </td><td class="markdownTableBodyNone">Value of the PDB occupancy field for the atom  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">index </td><td class="markdownTableBodyNone">Index of the atom  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">resindex </td><td class="markdownTableBodyNone">Residue index of the atom  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">resid </td><td class="markdownTableBodyNone">Resid of the atom  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">distance </td><td class="markdownTableBodyNone">The distance of atom from given point, line or plane. See <a class="el" href="core.html#dist_sel">description of distance selections</a> for details.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Words <em>index</em>, <em>resindex</em> and <em>resid</em> could be either keywords followed by multiple values or numeric properties depending on the context: <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Selection string </th><th class="markdownTableHeadNone">Interpretation  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"resid 1 2 3 4-10" </td><td class="markdownTableBodyNone">interpreted as <a class="el" href="core.html#keyword_sel">keyword selection</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"resid &gt; 25" </td><td class="markdownTableBodyNone">interpreted as <a class="el" href="core.html#num_prop">numeric property</a> in <a class="el" href="core.html#num_expr">numerical expression</a>.  </td></tr>
</table>
</dd></dl>
<h3><a class="anchor" id="num_expr"></a>
Numeric expressions</h3>
<p>Numerical expressions consist of <a class="el" href="core.html#num_prop">numerical properties</a>, integer of float point literals and common arithmetic operators "+", "-", "*", "/". Raising to any integer or fractional power is possible using either "^" or "**" operators. Unary minus could be used to change the sign of expression. Operator precedence could be changed by parentheses. Numerical expressions are only meaningful as operands of <a class="el" href="core.html#num_comp">numeric comparisons</a>. Single number or single numerical property is also valid numerical expression.</p>
<h3><a class="anchor" id="num_comp"></a>
Numeric comparisons</h3>
<p>Numerical expressions are compared to each other by the common operators:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operator </th><th class="markdownTableHeadNone">Meaning </th><th class="markdownTableHeadNone">Example  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"&gt;" </td><td class="markdownTableBodyNone">Greater than </td><td class="markdownTableBodyNone">x &gt; 3  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"&lt;" </td><td class="markdownTableBodyNone">Lower than </td><td class="markdownTableBodyNone">y &lt; 5.6  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"=" </td><td class="markdownTableBodyNone">Equal </td><td class="markdownTableBodyNone">resid = 45  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"&lt;&gt;" </td><td class="markdownTableBodyNone">Not equal </td><td class="markdownTableBodyNone">resid &lt;&gt; 14  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"&gt;=" </td><td class="markdownTableBodyNone">Greater or equal </td><td class="markdownTableBodyNone">index &gt;= 15  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"&lt;=" </td><td class="markdownTableBodyNone">Lower or equal </td><td class="markdownTableBodyNone">resindex &lt;= 100  </td></tr>
</table>
<p>The comparisons could be chained to select the ranges:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Selection text </th><th class="markdownTableHeadNone">Meaning  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3 &lt; x &lt; 10 </td><td class="markdownTableBodyNone">Open range  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10 &gt; x &gt;= 3 </td><td class="markdownTableBodyNone">Semi-closed range  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100 &lt;= resid &lt;= 200 </td><td class="markdownTableBodyNone">Closed range  </td></tr>
</table>
<h3><a class="anchor" id="log_expr"></a>
Logical expressions</h3>
<p>Common logical operators "or", "and" and "not" are supported and could be used to construct arbitrary logical expressions: </p><div class="fragment"><div class="line">resid 1-10 or x&gt;15</div>
<div class="line">name CA CB and resname ALA</div>
<div class="line">not (name OW and resname SOL and resid &gt; 34)</div>
</div><!-- fragment --><h3><a class="anchor" id="within_sel"></a>
Within selections</h3>
<p>Within selections allow selecting atoms which are within given cutoff distance around other selection, called "central selection". The syntax of within selections in Pteros is the following: </p><div class="fragment"><div class="line">within &lt;distance&gt; [pbc|nopbc|periodic|noperiodic] [<span class="keyword">self</span>|noself] of &lt;central selection&gt;</div>
</div><!-- fragment --><p>Distance is in nm.</p>
<p>Optional keywords "pbc" or "periodic" mean that selection takes into account periodic boundary conditions. Keywords "nopbc" or "noperiodic" means that periodicity is switched off. By default periodicity is off.</p>
<p>The optional keyword "self" means that central selection itself is also included into resulting selection. If "noself" is specified the central selection is excluded from result. The default is "self".</p>
<p>Keywords "pbc|nopbc" and "self|noself" can go in any order.</p>
<p>Here are some examples:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Selection text </th><th class="markdownTableHeadNone">What is selected  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">within 3.0 of protein </td><td class="markdownTableBodyNone">All atoms within 3.0 nm from any protein atom including the protein itself. Not periodic.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">within 3.0 pbc of protein </td><td class="markdownTableBodyNone">Same as above but periodic.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">within 3.0 pbc noself of protein </td><td class="markdownTableBodyNone">Same as above but the protein itself is not included.  </td></tr>
</table>
<h3><a class="anchor" id="by_res"></a>
By residue selections</h3>
<p>The "by residue &lt;central selection&gt;" operator is used to select whole residues, which are referenced by the central selection. This means that if at least one atom of particular residue is present in central selection then the whole residue would be selected.</p>
<dl class="section warning"><dt>Warning</dt><dd>The "by residue" operation has lower precedence than logical operators thus its operand have to be put into the parentheses if it contains logical operations: "by residue (name CA and resid 1 4 5)".</dd></dl>
<h3><a class="anchor" id="dist_sel"></a>
Distance selections</h3>
<p>Distance selections are unique for Pteros and allow selecting atoms by their distance from given reference point, line or plane. Their syntax is the following: </p><div class="fragment"><div class="line">dist|distance point|vector|plane [pbc|nopbc|periodic|noperiodic] x0 y0 z0 [x1 y1 z1]</div>
</div><!-- fragment --><p>The keyword "dist" and "distance" are synonyms. If "point" is specified than three float point numbers x0, y0, z0 are expected. For "vector" and "distance" six float point numbers x0, y0, z0, x1, y1, z1 are expected.</p>
<p>Optional keywords "pbc" or "periodic" mean that selection takes into account periodic boundary conditions. Keywords "nopbc" or "noperiodic" means that periodicity is switched off. By default periodicity is off.</p>
<p>In the case of "dist vector" (x0,y0,z0) give the point in space and (x1,y1,z1) specify <b>direction</b> of the vector originating from this point (direction is normalized automatically). The distance from the atoms to this vector is evaluated.</p>
<p>In the case of "dist plane" (x0,y0,z0) give the point in space and (x1,y1,z1) specify the <b>normal vector</b> of the plane originating in this point (the normal vector is normalized automatically). The distance from the atoms to this plane is evaluated.</p>
<p>Distance keyword operates on per-atom basis and is treated as <a class="el" href="core.html#num_prop">numeric property</a> of the atom:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Selection text </th><th class="markdownTableHeadNone">What is selected  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dist point 12.4 34.3 45.1 &lt; 3.0 </td><td class="markdownTableBodyNone">Atoms within 3.0 nm from the point "12.4 34.3 45.1"  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dist point pbc 12.4 34.3 45.1 &lt; 3.0 </td><td class="markdownTableBodyNone">The same as above but periodic  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dist vector 2.1 3.3 3.5 1 0 0 &lt; 3.0 </td><td class="markdownTableBodyNone">Atoms within the cylinder with radius 3 nm and the axis going from point "2.1 3.3 3.5" along X axis (the direction vector is "1 0 0")  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3.0 &lt; dist plane 2.1 3.3 3.5 1 1 1 &lt; 5.0 </td><td class="markdownTableBodyNone">Selects the slabs of atoms which are between 3 and 5 nm from the plane which goes through the point "2.1 3.3 3.5" and has the normal "1 1 1".  </td></tr>
</table>
<h2><a class="anchor" id="text_based_sel"></a>
Text-based and coordinate-depensent selections</h2>
<p>Selections created by means of selection string (<em>text-based</em> selections) are a bit special in Pteros. The set of selected atoms may depends on atomic coordinates (for example for selection <code>x&gt;15</code> or <code>within 3.0 of y&lt;34</code>). These cases are recognized automatically and such <em>coordinate-dependent</em> selection are treated in special manner.</p>
<p>Coordinate-dependent selections have to be updated if atomic coordinates change. If the coordinates of atoms were changed manually without changing the current frame this have to be done by hand using <a class="el" href="classpteros_1_1Selection.html#a567f4918712a85e5daa2abfdd97c8269" title="Recomputes selection without re-parsing selection text.">Selection::apply()</a> method. If selection is not coordinate-dependent it does nothing.</p>
<p>If the user calls <a class="el" href="classpteros_1_1Selection.html#a5aed5a342a40331302d1f0ddeec05560" title="Set current frame for selection.">Selection::set_frame()</a> to change the frame selection points to then the coordinate-dependent selection calls apply() automatically to be consistent with new atomic coordinates.</p>
<p>It is also possible to re-parse selection text completely by calling <a class="el" href="classpteros_1_1Selection.html#acef1d0301b1d88fb45d2a732c4ffba2f" title="Recomputes selection completely.">Selection::update()</a>. This is necessary when the number of atoms (not only their coordinate) change. For non-textual selections it does nothing.</p>
<p>In most cases the feature of auto-update is very handy and saves a lot of time allowing not to bother about consistency of the coordinate-dependent selections with the current frame. However in certain cases such behavior is not desirable. For example one selects all water molecules around the protein in starting configuration using "resname SOL and within 3.0 of protein" and want to see how they diffuse in the course of MD simulation. Each update of the coordinate frame made by <a class="el" href="classpteros_1_1Selection.html#a5aed5a342a40331302d1f0ddeec05560" title="Set current frame for selection.">Selection::set_frame()</a> will select new water shell around protein, which is not what we want. In such case one can call <a class="el" href="classpteros_1_1Selection.html#a6cd43b07c7b95592da4980833d646f8d" title="&quot;Flattens&quot; selection by removing coordinate dependence and making it not text-based.">Selection::flatten()</a> method. It "flattens" selection to the plain set of indexes without any auto-update magic. </p><dl class="section warning"><dt>Warning</dt><dd>Flattening is not reversible! New text-based selection have to be created to turn auto-update on again.</dd></dl>
<p>Text-based status of selection is also lost immediately after any operation which modifies it externally (i.e. not by means of parsing selection string) such as using append(), remove() or invert(), using any logical operators with selections, etc. Current status of selection could be queries by <a class="el" href="classpteros_1_1Selection.html#abb9015f85d1f9c36b6eb3fdcbf88b16f" title="Returns true if selection was created from text string and false if it was constructed &#39;by hand&#39; by a...">Selection::text_based()</a> and <a class="el" href="classpteros_1_1Selection.html#adb52e2d7f4cc183adbd778a7659a8227" title="Returns true if selection is coordinate-dependent and is able to recompute itself on the change of fr...">Selection::coord_dependent()</a> methods.</p>
<h2><a class="anchor" id="subsel"></a>
Sub-selections</h2>
<p>Sub-selections allow selecting atoms <em>inside</em> existing selection (narrowing or refining existing selection in other terms). Sub-selections could be very useful in the following situation. Suppose that we need to create separate selections for N,C,CA and CB atoms of particular protein residue. With "normal" selections the following code could be used: </p><div class="fragment"><div class="line">Selection sel_N(sys,<span class="stringliteral">&quot;protein and resid 1 and name N&quot;</span>);</div>
<div class="line">Selection sel_C(sys,<span class="stringliteral">&quot;protein and resid 1 and name C&quot;</span>);</div>
<div class="line">Selection sel_CA(sys,<span class="stringliteral">&quot;protein and resid 1 and name CA&quot;</span>);</div>
<div class="line">Selection sel_CB(sys,<span class="stringliteral">&quot;protein and resid 1 and name CB&quot;</span>);</div>
</div><!-- fragment --><p> The problem with this code is that we are looping over <em>all</em> atoms in the system four times, ones in each selection. This is very inefficient since we only need to find our residue with "protein and resid 1" (one loop over all atoms) and then we need to search <em>inside</em> this residue four times (looping over ~10 atoms only). This problem is not apparent for small systems but becomes very painful for the systems with millions of atoms. Subselections solve this problem: </p><div class="fragment"><div class="line">Selection residue1(sys,<span class="stringliteral">&quot;protein and resid 1&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> sel_N = residue1.select(<span class="stringliteral">&quot;name N&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> sel_C = residue1.select(<span class="stringliteral">&quot;name C&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> sel_CA = residue1.select(<span class="stringliteral">&quot;name CA&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> sel_CB = residue1.select(<span class="stringliteral">&quot;name CB&quot;</span>);</div>
</div><!-- fragment --><p>Subselections inherit the system and frame from the parent. The search in sub-selections is performed over selected atoms of the parent only (the only exception from this rule are within selections which involve seacrh over all atoms by design).</p>
<p>Subselections can also accept the pair of <em>local</em> indexes or the vector of <em>local</em> indexes: </p><div class="fragment"><div class="line">Selection residue1(sys,<span class="stringliteral">&quot;protein and resid 1&quot;</span>);</div>
<div class="line"><span class="comment">// Select range of atoms 1-4 inclusive in parent selection</span></div>
<div class="line"><span class="keyword">auto</span> sel_1_4 = residue1.select(1,4);</div>
<div class="line"><span class="comment">// Select atoms 1,4,7 in parent selection</span></div>
<div class="line">vector&lt;int&gt; ind = {1,4,7};</div>
<div class="line"><span class="keyword">auto</span> sel_1_4_7 = residue1.select(ind);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This behavior of sub-selections is different from normal selections. Sub-selections are constructed by <em>local</em> indexes of parent selection, while normal selections - by <em>global</em> indexes in the system. There are no constructors for sub-selections taking iterators or callback functions.</dd></dl>
<p>Once sub-selection is created it is not distinguishable from the gnormal one. Particularly it could be modifyed as any other selection, reassigned, etc. Sub-selections are only special by the way of their creation.</p>
<dl class="section note"><dt>Note</dt><dd>Subselections in Python follow exactly the same syntax as in C++.</dd></dl>
<h2><a class="anchor" id="sel_comb"></a>
Combining selections</h2>
<p><a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> objects could be combined by logical operations to create new selections:</p>
<ul>
<li>
<p class="startli"><b>Logical AND</b> </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keyword">auto</span> new_sel = sel1 &amp; sel2;</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">new_sel = sel1 <span class="keywordflow">and</span> sel2</div>
</div><!-- fragment --> </td></tr>
</table>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Logical OR</b> </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keyword">auto</span> new_sel = sel1 | sel2;</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">new_sel = sel1 <span class="keywordflow">or</span> sel2</div>
</div><!-- fragment --> </td></tr>
</table>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Logical NOT</b> </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keyword">auto</span> new_sel = ~sel1;</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">new_sel = <span class="keywordflow">not</span> sel2</div>
</div><!-- fragment --> </td></tr>
</table>
<p class="endli"></p>
</li>
<li>
<b>Removing one selection from the other</b> <table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keyword">auto</span> new_sel = sel1 - sel2;</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">new_sel = sel2 - sel1</div>
</div><!-- fragment --> </td></tr>
</table>
Operator "-" creates new selection, by removing all atoms of sel2 from sel1. Parent selections are not modified. <dl class="section warning"><dt>Warning</dt><dd>This operator is <em>not</em> commutative! </dd></dl>
</li>
</ul>
<p>It is also possible to perform logical operation <em>in place</em> without creating new selections: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">In-place operation </th><th class="markdownTableHeadNone">Method  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Appending one selection to the other </td><td class="markdownTableBodyNone"><a class="el" href="classpteros_1_1Selection.html#ac70a32707d277346ccefdece6ab3cc3e" title="Append another selection to this one.">Selection::append()</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Removing atoms from one selection from the other </td><td class="markdownTableBodyNone"><a class="el" href="classpteros_1_1Selection.html#a4ab1ff808f276419ba23ed9b74f826ec" title="Remove all atoms of sel from current selection.">Selection::remove()</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Invert selection </td><td class="markdownTableBodyNone"><a class="el" href="classpteros_1_1Selection.html#abd772b69215ac54679d6716088d57668" title="Inverts selection in place by selecting those atoms which were not selected.">Selection::invert()</a>  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>append() and remove() methods also work with individual atom indexes.</dd></dl>
<h1><a class="anchor" id="access"></a>
Accessing properties of selected atoms</h1>
<p>If selection contains <em>N</em> atoms then they could be accessed by relative indexes from 0 to N-1 inclusive. Relative indexes are <em>NOT</em> the same as atomic indexes. <a class="el" href="classpteros_1_1Atom.html" title="Class which represents a single atom.">Atom</a> with global index 150 may have relative index 0 in one selection and 23 in the other. Relative indexes are very convenient in accessing properties of selected atoms. For this <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> class contains the set of <em>accessor methods</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Accessing atom properties could be rather confusing due to the differences in C++ and Python. These differences are dictated by very different architectures of C++ and Python languages.</dd></dl>
<h2><a class="anchor" id="cpp_access"></a>
Accessor methods in C++</h2>
<p>Accessor methos in C++ have the same names as the properties of atoms: <code>sel.index(i)</code> returns global index of atom with relative index i, <code>sel.name(i)</code> returns name of this atom, <code>sel.resname(i)</code> returns its residue name, etc.</p>
<p>Accessors <code>x(i)</code>, <code>y(i)</code> and <code>z(i)</code> give access to individual atomic coordinates of the current frame (the frame pointed by selection). The method <code>xyz(i)</code> returns the vector of all three coordinates. These accessors also accept frame index as optional second parameter: <code>z(i,fr)</code>, <code>xyz(i,fr)</code>, etc.</p>
<p>There are also accessors for periodic box associated with current frame pointed by selection (<code>box()</code>) and the time stamp of the pointed frame (<code>time()</code>). These methods are <em>not</em> available for arbitrary frames.</p>
<p>There are also special accessor: <code>vdw(i)</code> which returns the van der Waals radius of <em>i</em>-th atom and <code>element_name(i)</code> which returns element name based on either element number (if available) or the first name of atom name.</p>
<p>In C++ all of them are accessors inlined l-value functions. This means that they do not add any overhead in accessing atom properties and could be assinged to:</p>
<div class="fragment"><div class="line">Selection sel(system,<span class="stringliteral">&quot;name CA&quot;</span>);</div>
<div class="line"><span class="comment">// Read access</span></div>
<div class="line">cout &lt;&lt; sel.name(0) &lt;&lt; endl;</div>
<div class="line"><span class="comment">// Write access</span></div>
<div class="line">sel.name(0) = <span class="stringliteral">&quot;CB&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Accessing coordinates of the current frame</span></div>
<div class="line">cout &lt;&lt; sel.<a class="code" href="classpteros_1_1Selection.html#a5dda11576d03ccd8f5428ed18303ff4c">x</a>(0) &lt;&lt; endl;</div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>(0) = sel.<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>(0) + sel.<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Accessing coordinates of other frames</span></div>
<div class="line">cout &lt;&lt; sel.X(0,frame) &lt;&lt; endl;</div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>(0,frame) = sel.<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>(1,frame1) + sel.<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>(2,frame2);</div>
</div><!-- fragment --><h2><a class="anchor" id="py_access"></a>
Accessor methods in Python</h2>
<p>Due to language limitations in Python each accessor have to be prepended by "get" or "set" prefixes for read and write access respectively, which makes them rather clumsy and difficult to use. That is why accessors are not ported to Python and recommended way of accessing atom properties in using indexing (see below).</p>
<h2><a class="anchor" id="indexing"></a>
Indexing operator of Selection object</h2>
<p>Selections support indexing by "[]" operator. It returns special Atom_proxy object, which has the same set of atom property accessors as <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> itslef.</p>
<p>In C++ the only difference is that these accessors do not take relative atomic index since Atom_proxy stores it internally.</p>
<div class="fragment"><div class="line"><span class="comment">// Note that accessors do not take atom index as first argument!</span></div>
<div class="line"> </div>
<div class="line">Selection sel(system,<span class="stringliteral">&quot;name CA&quot;</span>);</div>
<div class="line"><span class="comment">// Read access</span></div>
<div class="line">cout &lt;&lt; sel[0].name() &lt;&lt; endl;</div>
<div class="line"><span class="comment">// Write access</span></div>
<div class="line">sel[0].name() = <span class="stringliteral">&quot;CB&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Accessing coordinates of the current frame</span></div>
<div class="line">cout &lt;&lt; sel[0].<a class="code" href="classpteros_1_1Selection.html#a5dda11576d03ccd8f5428ed18303ff4c">x</a>() &lt;&lt; endl;</div>
<div class="line">sel[0].<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>() = sel[1].<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>() + sel[2].<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Accessing coordinates of other frame</span></div>
<div class="line">cout &lt;&lt; sel[{0,frame}].<a class="code" href="classpteros_1_1Selection.html#a5dda11576d03ccd8f5428ed18303ff4c">x</a>() &lt;&lt; endl;</div>
<div class="line">sel[{0,frame}].<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>() = sel[{1,frame1}].<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>() + sel[{2,frame2}].<a class="code" href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">xyz</a>();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The indexing operator can optionally take an std::pair of {index,frame} in order to access to arbitrariry frame.</dd></dl>
<p>In Python Atom_proxy objects benefit from the Python properties, which makes the usage of indexing much easier than the direct usage of accessors:</p>
<div class="fragment"><div class="line"><span class="comment"># Recommended way in Python</span></div>
<div class="line"> </div>
<div class="line">sel = Selection(system, <span class="stringliteral">&#39;name CA&#39;</span>)</div>
<div class="line"><span class="comment"># Read access</span></div>
<div class="line"><span class="keywordflow">print</span> sel[0].name</div>
<div class="line"><span class="comment"># Write access</span></div>
<div class="line">sel[0].name = <span class="stringliteral">&quot;CB&quot;</span></div>
<div class="line"><span class="comment"># Note that &#39;name&#39; is a property, not a method!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># This also works for coordinates of the current frame:</span></div>
<div class="line"><span class="keywordflow">print</span> sel[0].x, sel[0].xyz</div>
<div class="line">sel[0].xyz = sel[1].xyz + sel[2].xyz</div>
<div class="line"> </div>
<div class="line"><span class="comment"># and for the coordinates of the other frame</span></div>
<div class="line">sel[0,frame].xyz = sel[1,frame1].xyz + sel[2,frame2].xyz</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Creation of proxy objects makes access by indexing a bit <em>slower</em> than direct usage of accessor methods of <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a>. The difference is neglegible in most situations but do not use it in performance-critical parts of the code.</dd></dl>
<h2><a class="anchor" id="sel_iter"></a>
Iterating over selected atoms</h2>
<p>There are two ways to iterate over selected atoms - using <em>relative selection indexes</em> and using <em>iterators</em>.</p>
<p>The first variant uses either accessor methods or indexing operator to get atom properties: </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">Selection sel(system, <span class="stringliteral">&quot;name CA CB&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage of accessor methods for each atom property</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; sel.<a class="code" href="classpteros_1_1Selection.html#ab05fdad1136802ff0cc08ce41c16ffe9">size</a>(); ++i){</div>
<div class="line">    cout &lt;&lt; sel.name(i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sel.resname(i) &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage of indexing operator (slower than property accessors and not recommended in C++!)</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; sel.<a class="code" href="classpteros_1_1Selection.html#ab05fdad1136802ff0cc08ce41c16ffe9">size</a>(); ++i){</div>
<div class="line">    cout &lt;&lt; sel[i].name() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sel[i].resname() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sel = Selection(system, <span class="stringliteral">&#39;name CA CB&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Usage of indexing operator (still not the best way in Python, see below)</span></div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(sel.size()):</div>
<div class="line">    <span class="keywordflow">print</span> sel[i].name, sel[i].resname</div>
</div><!-- fragment --> </td></tr>
</table>
<p>The second way is using built-in iterators of <a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> objects: </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">Selection sel(system, <span class="stringliteral">&quot;name CA CB&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage of explicit iterators</span></div>
<div class="line">Selection::iterator it;</div>
<div class="line"><span class="keywordflow">for</span>(it=sel.<a class="code" href="classpteros_1_1Selection.html#aa5551a11482b6db769c5cf5ff4401c2b">begin</a>(); it!=sel.<a class="code" href="classpteros_1_1Selection.html#a4860c72c4146ebb1c32df5bb09f7dc8a">end</a>(); it++){</div>
<div class="line">    cout &lt;&lt; it-&gt;name() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; it-&gt;resname() &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage of range-based for loop in C++11 and higher</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; a: sel){</div>
<div class="line">    cout &lt;&lt; a.name() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; a.resname() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sel = Selection(system, <span class="stringliteral">&#39;name CA CB&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Recommended way in Python</span></div>
<div class="line"><span class="keywordflow">for</span> a <span class="keywordflow">in</span> sel:</div>
<div class="line">    <span class="keywordflow">print</span> a.name, a.resname</div>
</div><!-- fragment --> </td></tr>
</table>
<h2><a class="anchor" id="uniform_prop"></a>
Getting particular property of all selected atoms</h2>
<p>There is a set of methods allowing to get particular property of all selected atoms at the same time. These methods have the names "get_&lt;property&gt;()" and "set_&lt;property&gt;()" where property is name, resname, resid, beta, x, y, z, xyz, etc. In C++ getters return either std::vector for strings and char properties or Eigen::Vector for integer and float properties. Setters accept the same vectors as corresponding getters return. It is also possible to call setterss with simgle value which will "fill" all selected atoms. In Python the lists are used for strings and chars and numpy arrays for ints and floats:</p>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="keyword">auto</span> resids = sel.<a class="code" href="classpteros_1_1Selection.html#a39a9e8d557b0fc6f09e5dd43f823e625">get_resid</a>();</div>
<div class="line">resids[5] += 4;</div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#a080f7e4eb1cad42e5f3e618e2c1661a4">set_resid</a>(resids);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set all atom names to CA</span></div>
<div class="line">sel.<a class="code" href="classpteros_1_1Selection.html#aa069d656b8e8571abdec9223adce27be">set_name</a>(<span class="stringliteral">&quot;CA&quot;</span>);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">resids = sel.get_resid()</div>
<div class="line">resids[5] += 4</div>
<div class="line">sel.set_resid(resids)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Set all atom names to CA</span></div>
<div class="line">sel.set_name(<span class="stringliteral">&#39;CA&#39;</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<p>There are also methods "get_unique_&lt;property&gt;()" which return the vector of unique properties in selection. For example in order to get the list of all residue ids in selection: </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">sel = system.select_all();</div>
<div class="line"><span class="keyword">auto</span> resids = sel.<a class="code" href="classpteros_1_1Selection.html#a39a9e8d557b0fc6f09e5dd43f823e625">get_resid</a>();</div>
<div class="line"><span class="comment">// May return 1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,4,4,...</span></div>
<div class="line">resids = sel.get_unique_resid();</div>
<div class="line"><span class="comment">// Returns 1,2,3,4,5,...</span></div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sel = system.select_all()</div>
<div class="line">resids = sel.get_resid()</div>
<div class="line"><span class="comment">#May return 1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,4,4,...</span></div>
<div class="line">resids = sel.get_unique_resid()</div>
<div class="line"><span class="comment"># Returns 1,2,3,4,5,...</span></div>
</div><!-- fragment --> </td></tr>
</table>
<h1><a class="anchor" id="sys_build"></a>
Building molecular systems</h1>
<p>Pteros has reach set of methods for building molecular systems. They are not oriented on particular type of molecules like proteins or nucleic acids but allow manipulating atoms and selections in general.</p>
<h2><a class="anchor" id="atom_add_del"></a>
Adding and deleting atoms</h2>
<p>Adding and deleting atoms in the system is rather expensive operation due to internal data organization. It is much faster to add or delete the list of several atoms at once than doing this by one atom at a time.</p>
<p>In order to add one or more atoms use <a class="el" href="classpteros_1_1System.html#a4b38c192bfa2e0fda306c36c04a9cdaf" title="Adds new atoms from supplied vectors of atoms and coordinates. Atoms are placed at the end of the sys...">System::atoms_add()</a> method:</p>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">vector&lt;Atom&gt; atoms(N);</div>
<div class="line">vector&lt;Vector3f&gt; coords(N);</div>
<div class="line"><span class="keywordflow">for</span>(i=0;i&lt;N;++i){</div>
<div class="line">    Atom at;</div>
<div class="line">    at.name = <span class="charliteral">&#39;C&#39;</span></div>
<div class="line">    at.resid = i;</div>
<div class="line">    atoms.push_back(at);</div>
<div class="line">    coords.push_back(Vector3f(x,y,z));</div>
<div class="line">}</div>
<div class="line">Selection added_atoms = system.atoms_add(atoms,ccords);</div>
</div><!-- fragment --> </td><td><div class="fragment"></div><!-- fragment --> </td></tr>
</table>
<h2><a class="anchor" id="append_remove"></a>
Appending and removing systems and selections</h2>
<h2><a class="anchor" id="distib"></a>
Multiplying selections</h2>
<h2><a class="anchor" id="rearrange"></a>
Rearranging atoms</h2>
<p>There is a common problem of rearranging the atoms in the system in particular order, which is especially important for preparing MD topologies. In Pteros this is easily acomplished with <a class="el" href="classpteros_1_1System.html#aaa0a10f0562b2b6f6441ca29120a6b5e" title="Rearranges the atoms in the order of provided selection strings.">System::rearrange()</a> method. It takes a vector of selections or the vector of selection strings and arranges the atoms in the order of these selections. The atoms, which do not belong to any of provided selections are placed at the end in their initial order. </p><dl class="section warning"><dt>Warning</dt><dd>Selections should not overlap (an exception is thrown if they are). Empty selections are not allowed. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method rearranges the atom indexes only (shuffles the order of atoms). Residue or chain ids are not changed. If you need to reorder atoms by residues look at <a class="el" href="classpteros_1_1System.html#a521c0ce9af1da689a66c21d2bf23321d" title="Sorts atoms by resindex arranging atoms with the same resindexes into contigous pieces.">System::sort_by_resindex()</a> method. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method affects all frames and could be slow for very large systems and and/or large number of frames.</dd></dl>
<h1><a class="anchor" id="pbc"></a>
Working with periodicity</h1>
<p>Pteros is designed to work with arbitrary triclinic periodic boxes. There are several ways of accounting for periodicity:</p>
<ul>
<li>Many methods, which are aware of periodicity, have an optional boolean parameter "periodic" that switches on periodic computations.</li>
<li>Periodicity could be taken into account explicitly by using Periodic_box class and its methods.</li>
</ul>
<p>Upon reading the data files Pteros sets the periodic box accordingly in the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> if it is present in the data file.</p>
<h2><a class="anchor" id="pbc_get_set"></a>
Getting, setting and modifying periodic box</h2>
<p>Periodic box could be extracted for each frame by using System::Box() method. Here is how to check if the periodic box is present: </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">System s(<span class="stringliteral">&quot;some_file.pdb&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>( s.Box(0).is_priodic() ) cout &lt;&lt; <span class="stringliteral">&quot;Box present for frame 0!&quot;</span> &lt;&lt; endl;</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">s = System(<span class="stringliteral">&#39;some_file.pdb&#39;</span>)</div>
<div class="line"><span class="keywordflow">if</span> s.getBox(0).is_periodic():</div>
<div class="line">    <span class="keywordflow">print</span> <span class="stringliteral">&#39;Box present for frame 0!&#39;</span></div>
</div><!-- fragment --> </td></tr>
</table>
<p>An important feature of the Periodic_box is that it stores some internal data (like inverse tranform matrices) and thus individual components of the box are immutable. In order to change the box you have to get it as a 3x3 matrix, edit this matrix and assign it back using Periodic_box::modify() method: </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">System s(<span class="stringliteral">&quot;some_file.pdb&quot;</span>);</div>
<div class="line"><span class="comment">// Get a box as matrix. Column 0 is vector a, column 1 is b, column 2 is c.</span></div>
<div class="line"><span class="keyword">auto</span> m = s.Box(0).get_matrix();</div>
<div class="line"><span class="comment">// Modify individual box element</span></div>
<div class="line">m(0,1) *= 2;</div>
<div class="line"><span class="comment">// Set it back</span></div>
<div class="line">s.box(0).modify(m);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">s = System(<span class="stringliteral">&#39;some_file.pdb&#39;</span>)</div>
<div class="line"><span class="comment"># Get a box as matrix. Column 0 is vector a, column 1 is b, column 2 is c.</span></div>
<div class="line">box = s.getBox(0).get_matrix()</div>
<div class="line"><span class="comment"># Modify individual matrix element</span></div>
<div class="line">m[0][1] *= 2</div>
<div class="line"><span class="comment"># Set modified box object to the System</span></div>
<div class="line">s.getBox(0).modify(m)</div>
</div><!-- fragment --> </td></tr>
</table>
<p>You can also get lengths of individual box vectors with Periodic_box::get_extent() or the lengths of all vectors with Periodic_box::get_extents(). It is also possible to extract an individual vector directly with Periodic_box::get_vector().</p>
<p>One common operation is scaling the peridic box without changing the angles between the vectors. This could be achieved with convenience function Periodic_box::scale_vectors(): </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">System s(<span class="stringliteral">&quot;some_file.pdb&quot;</span>);</div>
<div class="line"><span class="comment">// Scale all box vectors by x2</span></div>
<div class="line">vector&lt;float&gt; scale = {2,2,2};</div>
<div class="line">s.Box(0).scale_vectors(scale);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">s = System(<span class="stringliteral">&#39;some_file.pdb&#39;</span>)</div>
<div class="line"><span class="comment"># Scale all box vectors by x2</span></div>
<div class="line">s.getBox(0).scale_vectors([2,2,2])</div>
</div><!-- fragment --> </td></tr>
</table>
<p>It is also possible to get and set the box as a set of vector lengths (a,b,c) and the set of angles between the vectors (a^c, b^c, a^b). This is performed by the Periodic_box::to_vectors_angles() and Periodic_box::from_vectors_angles() methods: </p><table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">System s(<span class="stringliteral">&quot;some_file.pdb&quot;</span>);</div>
<div class="line">vector&lt;float&gt; vecs, angles;</div>
<div class="line"><span class="comment">// Get as vectors and angles</span></div>
<div class="line">s.Box(0).to_vectors_angles(vecs,angles);</div>
<div class="line"><span class="comment">// Modify a^b angle</span></div>
<div class="line">angles[2] *= 2;</div>
<div class="line"><span class="comment">// Set it back</span></div>
<div class="line">s.Box(0).from_vectors_angles(vecs,angles);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">System s(<span class="stringliteral">&#39;some_file.pdb&#39;</span>)</div>
<div class="line"><span class="comment"># Get as vectors and angles</span></div>
<div class="line">vecs,angles = s.getBox(0).to_vectors_angles()</div>
<div class="line"><span class="comment"># Modify a^b angle</span></div>
<div class="line">angles[2] *= 2</div>
<div class="line"><span class="comment"># Set it back</span></div>
<div class="line">s.getBox(0).from_vectors_angles(vecs,angles)</div>
</div><!-- fragment --> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The order of angles (a^c, b^c, a^b) is the same as in PDB CRYST1 record.</dd></dl>
<h2><a class="anchor" id="wrap"></a>
Wrapping and unwrapping</h2>
<p>There are several ways to wrap atoms or points into the box:</p><ul>
<li>Wrap an arbitrary point with Periodic_box::wrap_point()</li>
<li>Wrap the whole selection with <a class="el" href="classpteros_1_1Selection.html#a4636366a0fd89aa30eaca338abfba38c" title="Wraps whole selection to the periodic box.">Selection::wrap()</a></li>
<li>Wrap the whole system with <a class="el" href="classpteros_1_1System.html#abcb6fd36c0a1958e7c8b6357ca14d33a" title="Wrap all system to the periodic box for given frame.">System::wrap()</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All these methods take an optional parameter "dims" which tells which dimentions to wrap.</dd></dl>
<p>In contrast to wrapping unwrapping is non-trivial operation which could be done in different ways. Pteros supports two unwrapping methods: </p><ul>
<li>
Simple unwrapping is performed by <a class="el" href="classpteros_1_1Selection.html#a0c60213a1f1d81bb6f00d0d3401f39b5" title="Unwraps selection to make it whole if possible (without jumps over periodic box boundary).">Selection::unwrap()</a>. It uses the center of masses of selection as an "anchor" and sets all atoms of selection to their periodic images, which are closest to this anchor. <dl class="section warning"><dt>Warning</dt><dd>This method is very fast but only works if selection does not exceed 1/2 of the box size in any dimension! Otherwise it produces unpredictable results. </dd></dl>
</li>
<li>
Unwrapping by bonds is performed by <a class="el" href="classpteros_1_1Selection.html#a739a08e43b30435bfc8c5eb4fb2735c8" title="Unwraps selection to make it whole (without jumps over periodic box boundary).">Selection::unwrap_bonds()</a>. In this method the user supplies the maximal bond length and all atoms of selections which are within this distance are considered as connected by bonds. After that first atom in selection is set as an anchor (the anchor atom could be overriden by optional "leading_index" parameter) and all atoms connected to it are moved to their corresponding closest periodic images. The procedure is continued for all connected atoms. <dl class="section warning"><dt>Warning</dt><dd>This mehtod works for any size of selection but is <b>much</b> slower than simple unwrapping! </dd></dl>
</li>
</ul>
<h2><a class="anchor" id="pbc_measure"></a>
Periodic distances and closest images</h2>
<p>In order to compute the periodic distances the following methods could be used:</p><ul>
<li>Smallest periodic distance between two arbitrary points could be computed with Periodic_box::distance() and Periodic_box::distance_squared() methods.</li>
<li>Smallest periodic distance between two atoms could be computed with <a class="el" href="classpteros_1_1System.html#ab0b49bb3db424813d2ec7e6b2f602c74" title="Get distance between two atoms for given frame (periodic in given dimensions if needed).">System::distance()</a> method when optional parameter "periodic" is set to "true".</li>
</ul>
<p>Periodic_box::shortest_vector() computes the shortest vector between two arbitrary points. Periodic_box::get_closest_image() returns the periodic image of given point, which is closest to the anchor point.</p>
<dl class="section note"><dt>Note</dt><dd>All these methods take an optional parameter "dims" which tells which dimentions to treat as periodic.</dd></dl>
<h1><a class="anchor" id="dist_search"></a>
Fast distance search and spatial grids</h1>
<p>Pteros uses fast grid search algorithms for finding distances between the atoms. There are several variants of the distance seacrh which return either pairs of atoms within given cut-off distance or the list of atoms within given distance from point in space or other set of atoms.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="core.html#within_sel">Within selections</a> also use distance search algorithms under the hood.</dd></dl>
<h2><a class="anchor" id="dist_search_variants"></a>
Different forms of distance search</h2>
<h3><a class="anchor" id="search_1_sel"></a>
Searching contacts within single selection</h3>
<p>Use this function to search all contacts between the atoms within single selection.</p>
<dl class="section warning"><dt>Warning</dt><dd>In Python the signature of this function is different: <div class="fragment"><div class="line">(pairs,distances) search_contacts(cut_off, sel, absolute_index = <span class="keyword">False</span>, periodic = <span class="keyword">False</span>, do_dist = <span class="keyword">False</span>)</div>
</div><!-- fragment --> Instead of taking pairs and distance vectors as reference parameters they are returned as a tuple, which is Pythonic way of handling multiple return values. If the last parameter "do_dist" is "True" then distances are filled with actual values, otherwise second member of returned tuple is "None".</dd></dl>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Vector for found pairs</span></div>
<div class="line">vector&lt;Vector2i&gt; pairs;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cut-off distance in nm</span></div>
<div class="line"><span class="keywordtype">float</span> cut_off = 3.5;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Non-periodic search returning local indexes</span></div>
<div class="line">search_contacts(cut_off,sel,pairs);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Periodic search returning global indexes</span></div>
<div class="line">search_contacts(cut_off,sel,pairs,<span class="keyword">true</span>,<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but also return distances for each pair</span></div>
<div class="line">vector&lt;float&gt; distances;</div>
<div class="line">search_contacts(cut_off,sel,pairs,<span class="keyword">true</span>,<span class="keyword">true</span>,&amp;distances);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Cut-off distance in nm</span></div>
<div class="line">cut_off = 3.5</div>
<div class="line"> </div>
<div class="line"><span class="comment"># In Python search_contacts() *always*</span></div>
<div class="line"><span class="comment"># returns a tuple (pairs,distances)</span></div>
<div class="line"><span class="comment"># If no distances are requested the &#39;distances&#39;</span></div>
<div class="line"><span class="comment"># would be equal to None!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Non-periodic search returning local indexes</span></div>
<div class="line"><span class="comment"># We only take first member of the tuple (the pairs)</span></div>
<div class="line">pairs = search_contacts(cut_off,sel)[0]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Periodic search returning global indexes</span></div>
<div class="line"><span class="comment"># We only take first member of the tuple (the pairs)</span></div>
<div class="line">pairs = search_contacts(cut_off,sel,<span class="keyword">True</span>,<span class="keyword">True</span>)[0]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Same as above but also return distances for each pair</span></div>
<div class="line"><span class="comment"># Passing True in last argument instruct to fill distances with</span></div>
<div class="line"><span class="comment"># values instead of returning it as None.</span></div>
<div class="line">pairs,distances = search_contacts(cut_off,sel,<span class="keyword">True</span>,<span class="keyword">True</span>,<span class="keyword">True</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<h3><a class="anchor" id="search_2_sel"></a>
Searching contacts between two selections</h3>
<p>Use this function to search the contacts between two different selections. </p><dl class="section warning"><dt>Warning</dt><dd>In Python the signature of this function is different: <div class="fragment"><div class="line">(pairs,distances) search_contacts(cut_off, sel1, sel2, absolute_index = <span class="keyword">False</span>, periodic = <span class="keyword">False</span>, do_dist = <span class="keyword">False</span>)</div>
</div><!-- fragment --> Instead of taking pairs and distance vectors as reference parameters they are returned as a tuple, which Pythonic way of handling multiple return values. If the last parameter "do_dist" is "True" then distances are filled with actual values, otherwise second member of return tuple is "None".</dd></dl>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Vector for found pairs</span></div>
<div class="line">vector&lt;Vector2i&gt; pairs;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cut-off distance in nm</span></div>
<div class="line"><span class="keywordtype">float</span> cut_off = 3.5;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Non-periodic search returning local indexes</span></div>
<div class="line">search_contacts(cut_off,sel1,sel2,pairs);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Periodic search returning global indexes</span></div>
<div class="line">search_contacts(cut_off,sel1,sel2,pairs,<span class="keyword">true</span>,<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same as above but also return distances for each pair</span></div>
<div class="line">vector&lt;float&gt; distances;</div>
<div class="line">search_contacts(cut_off,sel1,sel2,pairs,<span class="keyword">true</span>,<span class="keyword">true</span>,&amp;distances);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Cut-off distance in nm</span></div>
<div class="line">cut_off = 3.5</div>
<div class="line"> </div>
<div class="line"><span class="comment"># In Python search_contacts() *always*</span></div>
<div class="line"><span class="comment"># returns a tuple (pairs,distances)</span></div>
<div class="line"><span class="comment"># If no distances are requested the &#39;distances&#39;</span></div>
<div class="line"><span class="comment"># would be equal to None!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Non-periodic search returning local indexes</span></div>
<div class="line"><span class="comment"># We only take first member of the tuple (the pairs)</span></div>
<div class="line">pairs = search_contacts(cut_off,sel1,sel2)[0]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Periodic search returning global indexes</span></div>
<div class="line"><span class="comment"># We only take first member of the tuple (the pairs)</span></div>
<div class="line">pairs = search_contacts(cut_off,sel1,sel2,<span class="keyword">True</span>,<span class="keyword">True</span>)[0]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Same as above but also return distances for each pair</span></div>
<div class="line"><span class="comment"># Passing True in last argument instruct to fill distances with</span></div>
<div class="line"><span class="comment"># values instead of returning it as None.</span></div>
<div class="line">pairs,distances = search_contacts(cut_off,sel1,sel2,<span class="keyword">True</span>,<span class="keyword">True</span>,<span class="keyword">True</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<h3><a class="anchor" id="search_within"></a>
Searching around given selection</h3>
<p>Use pteros::search_within() function to search all atoms from <em>source selection</em> which are within given distance from any atom of <em>target selection</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>In Python the signature of this function is different: <div class="fragment"><div class="line">indexes = search_contacts(cut_off, source, target, include_self = <span class="keyword">True</span>, periodic = <span class="keyword">False</span>)</div>
</div><!-- fragment --> Indexes are returned instead of being passed by reference, which is Pythonic way of handling this situation.</dd></dl>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Source selection is water</span></div>
<div class="line"><span class="keyword">auto</span> source_sel = system(<span class="stringliteral">&quot;resname SOL&quot;</span>);</div>
<div class="line"><span class="comment">// Target selection is protein</span></div>
<div class="line"><span class="keyword">auto</span> target_sel = system(<span class="stringliteral">&quot;protein&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vector of found atom indexes</span></div>
<div class="line"><span class="comment">// Absolute indexes are returned!</span></div>
<div class="line">vector&lt;int&gt; result;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> cut_off = 3.5; <span class="comment">// in nm</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Find all atoms of source in 3.5 nm shell around target</span></div>
<div class="line"><span class="comment">// not including target itself accounting for periodicity</span></div>
<div class="line">search_within(cut_off, source_sel, target_sel, result, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Source selection is water</span></div>
<div class="line">source_sel = system(<span class="stringliteral">&#39;resname SOL&#39;</span>)</div>
<div class="line"><span class="comment"># Target selection is protein</span></div>
<div class="line">target_sel = system(<span class="stringliteral">&#39;protein&#39;</span>)</div>
<div class="line"> </div>
<div class="line">cut_off = 3.5 <span class="comment"># in nm</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Find all atoms of source in 3.nm 5 shell around target</span></div>
<div class="line"><span class="comment"># not including target itself accounting for periodicity</span></div>
<div class="line"><span class="comment"># Absolute indexes are returned!</span></div>
<div class="line">result = search_within(cut_off, source_sel, target_sel, <span class="keyword">False</span>, <span class="keyword">True</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<h3><a class="anchor" id="repeated_search"></a>
Repeated searching around multiple targets</h3>
<p>There is a common situation when one needs to find, for example, water molecules around multiple protein residues or around head group of each lipid in the membrane. In this scenario the source selection (water) is always the same, while the target selection changes and multiple searches have to be done. Usage of pteros::search_within() function is not optimal in this case bacause it will redundantly distribute source atoms to the same grid multiple times. In this case the Distance_search_within provides <em>much</em> better performance. This class is initialized with source selection and then allows to search around different targets efficiently multple times. It also allows searching around fixed points in space.</p>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line"><span class="comment">// Source selection for water</span></div>
<div class="line"><span class="keyword">auto</span> water = system(<span class="stringliteral">&quot;resname SOL&quot;</span>);</div>
<div class="line"><span class="comment">// Multiple target selections for 20 protein residues</span></div>
<div class="line">vector&lt;Selection&gt; residues;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;20; i++){</div>
<div class="line">    residues[i].modify(system,<span class="stringliteral">&quot;protein and resid &quot;</span>+to_string(i));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Vector of vectors for results</span></div>
<div class="line">vector&lt;vector&lt;int&gt;&gt; results(20);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialise for periodic search and to return local indexes</span></div>
<div class="line">Distance_search_within seacrher(3.5, water, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Search for each residue</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;20; i++){</div>
<div class="line">    searcher.seacrh_within(residues[i], results[i]);</div>
<div class="line">}</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><span class="comment"># Source selection for water</span></div>
<div class="line">water = system(<span class="stringliteral">&#39;resname SOL&#39;</span>)</div>
<div class="line"><span class="comment"># Multiple target selections for 20 protein residues</span></div>
<div class="line">residues = []</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(20):</div>
<div class="line">    sel = system(<span class="stringliteral">&quot;protein and resid %i&quot;</span> % (i+1))</div>
<div class="line">    residues.append(sel);</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Storage for results</span></div>
<div class="line">results = []</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Initialise for periodic search and to return local indexes</span></div>
<div class="line">searcher = Distance_search_within(3.5, water, <span class="keyword">False</span>, <span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Search for each residue</span></div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(20):</div>
<div class="line">    res = searcher.search_within(residues[i+1]);</div>
<div class="line">    results.append(res);</div>
</div><!-- fragment --> </td></tr>
</table>
<h2><a class="anchor" id="custom_grid"></a>
Custom spatial grids</h2>
<p>Sometimes one does not need to do a distance searcg but want to distribute the atoms from given selection into spatial grid. This is useful for computing 3D density distributions, occupancy volumetric hystograms, velocity fields, etc. This task is perfromed by <a class="el" href="classpteros_1_1Grid.html" title="Sorting the atoms from given selection into the cells of 3D grid with given dimensions.">Grid</a> class.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classpteros_1_1Grid.html" title="Sorting the atoms from given selection into the cells of 3D grid with given dimensions.">Grid</a> is used internally by all distance search functions, thus it is rather <em>low-level</em> class. Particularly grid cells contain raw pointers to atomic coordinates, which are treated in a complex way internally. In periodic grids they may point not to actual atoms but to temporary wrapped coordinates.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classpteros_1_1Grid.html" title="Sorting the atoms from given selection into the cells of 3D grid with given dimensions.">Grid</a> is currently C++ only.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Create 100x100x100 grid</span></div>
<div class="line"><span class="keywordtype">int</span> N = 100;</div>
<div class="line">Grid g(N,N,N);</div>
<div class="line"><span class="comment">// Populate it from given selection</span></div>
<div class="line"><span class="comment">// in periodic manner</span></div>
<div class="line">g.populate_periodic(sel);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print number of atoms in the grid cells</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;N;++i){</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;N;++j)</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0;k&lt;N;++k)</div>
<div class="line">            cout &lt;&lt; g.cell(i,j,k).size() &lt;&lt; endl;</div>
</div><!-- fragment --><p><a class="el" href="classpteros_1_1Grid.html" title="Sorting the atoms from given selection into the cells of 3D grid with given dimensions.">Grid</a> cells are of type <code>vector&lt;Grid_element&gt;</code> and contain information about indexes and coordinates of atoms in each cell.</p>
<h1><a class="anchor" id="energy"></a>
Evaluating non-bond energies</h1>
<p>Pteros is able to compute the <em>short-range</em> non-bond energies if topology file is read for the system. Currently Pteros reads Gromacs tpr run input files to extract topology and some energy evaluation options from them.</p>
<dl class="section warning"><dt>Warning</dt><dd>Long-range electrostatics with PME or other lattice sum methods are not supported in Pteros.</dd></dl>
<p>Treatment of non-bonded interactions in Gromacs is, unfortunately, complex and rather confusing. Coulomb and van-der-Waals interactions have a type and a modifier. The type is the functional form of interaction and the modifier is a special function, which is used to avoid the discontinuity of derivatives at cut-off distance. In practice different combinations of types and modifiers in Gromacs .mdp files lead to non-trivial and confusing choises of actual interaction functions. Pteros is trying to match these complex rules as close as possible but it is not guaranteed that the results would be numerically identical.</p>
<dl class="section note"><dt>Note</dt><dd>Pteros is known to produce correct results for MARTINI coarse grained force field and simple cut-off interactions.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Reading topologies in tpr format requires linking with Gromacs. Evaluation of energies is not possible otherwise.</dd></dl>
<p>All energy evaluation methods return an object of type Eigen::Vector2f where the first number if Coulomb energy and the second is Van der Waals energy.</p>
<h2><a class="anchor" id="get_en"></a>
Computing non-bond energies</h2>
<p>Before evaluating non-bond energies the user should always check if the <a class="el" href="classpteros_1_1System.html" title="The system of atoms.">System</a> has correctly set force field parameters by calling System::force_field_ready(). If it returns <code>true</code> than it is safe to call energy functions. </p><dl class="section warning"><dt>Warning</dt><dd>The Pteros will crash if calling energy functions on system without force field (i.e. without any topology loaded). No check is made in energy functions themselves for efficiency reasons.</dd></dl>
<p><a class="el" href="classpteros_1_1Selection.html" title="Selection class.">Selection</a> class provides two higher-level methods of energy evaluation. The first one computes self-energy of selection within given distance cut-off. The second computes the energy between two selection of the same size within given cut-off for given frame.</p>
<dl class="section note"><dt>Note</dt><dd>If cutoff is zero the minimum of Coulomb and VdW cutoffs from tpr file is used. This is recommended way of computing energies since it is most consistent with results from Gromacs.</dd></dl>
<table border="0" width="100%">
<tr>
<td align="center" width="50%">C++</td><td align="center" width="50%">Python</td></tr>
<tr>
<td><div class="fragment"><div class="line">Selection sel1(sys,<span class="stringliteral">&quot;name CA&quot;</span>);</div>
<div class="line">Selection sel2(sys,<span class="stringliteral">&quot;name CB&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if it is safe to compute energies</span></div>
<div class="line"><span class="keywordflow">if</span>(sys.force_field_ready()){</div>
<div class="line">    <span class="comment">// Energy of all atom pairs within 0.3 nm accounting for periodicity</span></div>
<div class="line">    <span class="keyword">auto</span> self_en = sel1.<a class="code" href="classpteros_1_1Selection.html#a766e4ac6d12b731df1087cf1fbc9588f">non_bond_energy</a>(0.3, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Interaction between two selections within default cutoff for frame 3</span></div>
<div class="line">    <span class="comment">// and accounting for periodicity</span></div>
<div class="line">    <span class="keyword">auto</span> en12 = non_bond_energy(sel1, sel2, 0, 3, <span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">sel1 = sys(<span class="stringliteral">&quot;name CA&quot;</span>)</div>
<div class="line">sel2 = sys(<span class="stringliteral">&quot;name CB&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Check if it is safe to compute energies</span></div>
<div class="line"><span class="keywordflow">if</span> sys.force_field_ready():</div>
<div class="line">    <span class="comment"># Energy of all atom pairs within 0.3 nm accounting for periodicity</span></div>
<div class="line">    self_en = sel1.non_bond_energy(0.3, <span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Interaction between two selections within default cutoff for frame 3</span></div>
<div class="line">    <span class="comment"># and accounting for periodicity</span></div>
<div class="line">    en12 = non_bond_energy(sel1, sel2, 0, 3, <span class="keyword">True</span>)</div>
</div><!-- fragment --> </td></tr>
</table>
<h1><a class="anchor" id="dssp"></a>
Secondary structure of proteins</h1>
<p>Pteros uses <a href="http://www.cmbi.ru.nl/dssp.html">DSSP</a> method for determining secondary structure of proteins. <a class="el" href="classpteros_1_1Selection.html#aaa83545bc2569154a0b885a17100449a" title="Determines secondary structure with DSSP algorithm and writes detailed report to file.">Selection::dssp()</a> writes detailed DSSP report to the file or to the stream if file name of stream object are provided as an argument. If called without arguments the DSSP string is returned with letter-code for secondary structure. The encoding is the same as in original DSSP program:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Structure </th><th class="markdownTableHeadNone">code  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">alphahelix </td><td class="markdownTableBodyNone">H  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">betabridge </td><td class="markdownTableBodyNone">B  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">strand </td><td class="markdownTableBodyNone">E  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">helix_3 </td><td class="markdownTableBodyNone">G  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">helix_5 </td><td class="markdownTableBodyNone">I  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">turn </td><td class="markdownTableBodyNone">T  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bend </td><td class="markdownTableBodyNone">S  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">loop </td><td class="markdownTableBodyNone">' ' (space)  </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classpteros_1_1Selection.html#aaa83545bc2569154a0b885a17100449a" title="Determines secondary structure with DSSP algorithm and writes detailed report to file.">Selection::dssp()</a> always works with whole protein residues and ignores everything else. Internally it makes new sub-selection "by residue protein" and the secondary structure is computed on it and not on original selection. Keep this in mind if your original selection contains non-protein residues since the resulting string won't match exactly the residues in you selection in this case!</dd></dl>
<h1><a class="anchor" id="measure_sasa"></a>
Solvent accessible surface area</h1>
<p>Solvent accessible surface area (SASA) is computed in Pteros using two different algorithms:</p><ul>
<li><a class="el" href="classpteros_1_1Selection.html#a6c7a6301a3039d77c6ffe7cc61726012" title="Get the SASA using powersasa algorithm. Returns area and computes volume and per-atom values if asked...">Selection::powersasa()</a>. Implements modern and robust POWERSASA algorithm developed in the <a href="http://www.kit.edu/english/">Karlsruhe Institute of Technology</a> and inclided into <a href="http://www.int.kit.edu/1636.php">SIMONA</a> package. This is fast algorithm of computing area of the molecules based on rather complex theory of power diagrams (<a href="http://onlinelibrary.wiley.com/doi/10.1002/jcc.21844/abstract">paper</a>). The method <a class="el" href="classpteros_1_1Selection.html#a6c7a6301a3039d77c6ffe7cc61726012" title="Get the SASA using powersasa algorithm. Returns area and computes volume and per-atom values if asked...">Selection::powersasa()</a> returns the solvent accessible area of atoms in selection. Optional argument could be used to set the probe radius and to get additional data like total volume, area per atom and volume per atom.</li>
<li><a class="el" href="classpteros_1_1Selection.html#a83fab26d0b95584d51d4e1c4b2395cc9" title="Get SASA using Shrake and Rupley algorithm (slower than powersasa and can&#39;t compute volumes)">Selection::sasa()</a>. Implements older and slower Shrake and Rupley algorithm. The code is borrowed from <a href="mdtraj.org">MDTraj</a>. It is free from licence restrictions of POWERSASA (see note below) but slower and less functional, particularly it can't compute volumes.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>POWERSASA code is not open source. I contacted the authors of POWERSASA several times to ask for official permision to use their code in Pteros but all requestes were ignored. I concluded that nobody is concerned about the licensing of POWERSASA now. However, compilation of this code is disabled by default. See <a class="el" href="install.html#sasa">SASA code</a> for details how to enable it. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclasspteros_1_1Selection_html_acb686c3677aa6b652ca47e792e034a40"><div class="ttname"><a href="classpteros_1_1Selection.html#acb686c3677aa6b652ca47e792e034a40">pteros::Selection::modify</a></div><div class="ttdeci">void modify(std::string str, int fr=0)</div><div class="ttdoc">Modifies selection string in existing selection.</div><div class="ttdef"><b>Definition:</b> selection.cpp:387</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_a080f7e4eb1cad42e5f3e618e2c1661a4"><div class="ttname"><a href="classpteros_1_1Selection.html#a080f7e4eb1cad42e5f3e618e2c1661a4">pteros::Selection::set_resid</a></div><div class="ttdeci">void set_resid(const std::vector&lt; int &gt; &amp;data)</div><div class="ttdoc">Set resid's in selection from supplied vector.</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_ab05fdad1136802ff0cc08ce41c16ffe9"><div class="ttname"><a href="classpteros_1_1Selection.html#ab05fdad1136802ff0cc08ce41c16ffe9">pteros::Selection::size</a></div><div class="ttdeci">int size() const</div><div class="ttdoc">Get the size of selection.</div><div class="ttdef"><b>Definition:</b> selection.h:747</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_a4860c72c4146ebb1c32df5bb09f7dc8a"><div class="ttname"><a href="classpteros_1_1Selection.html#a4860c72c4146ebb1c32df5bb09f7dc8a">pteros::Selection::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdoc">End iterator.</div><div class="ttdef"><b>Definition:</b> selection.cpp:680</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_a0671ecf29f52dd438a5870dd44314c87"><div class="ttname"><a href="classpteros_1_1Selection.html#a0671ecf29f52dd438a5870dd44314c87">pteros::Selection::set_system</a></div><div class="ttdeci">void set_system(const System &amp;sys)</div><div class="ttdoc">Sets new system for selection.</div><div class="ttdef"><b>Definition:</b> selection.cpp:296</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_aa5551a11482b6db769c5cf5ff4401c2b"><div class="ttname"><a href="classpteros_1_1Selection.html#aa5551a11482b6db769c5cf5ff4401c2b">pteros::Selection::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">Begin iterator.</div><div class="ttdef"><b>Definition:</b> selection.cpp:676</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_a766e4ac6d12b731df1087cf1fbc9588f"><div class="ttname"><a href="classpteros_1_1Selection.html#a766e4ac6d12b731df1087cf1fbc9588f">pteros::Selection::non_bond_energy</a></div><div class="ttdeci">Eigen::Vector2f non_bond_energy(float cutoff=0, bool pbc=true) const</div><div class="ttdoc">Self-energy of selection computed within given interaction cut-off.</div><div class="ttdef"><b>Definition:</b> selection.cpp:1321</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_aa069d656b8e8571abdec9223adce27be"><div class="ttname"><a href="classpteros_1_1Selection.html#aa069d656b8e8571abdec9223adce27be">pteros::Selection::set_name</a></div><div class="ttdeci">void set_name(const std::vector&lt; std::string &gt; &amp;data)</div><div class="ttdoc">Set atom names in selection from supplied vector.</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_a39a9e8d557b0fc6f09e5dd43f823e625"><div class="ttname"><a href="classpteros_1_1Selection.html#a39a9e8d557b0fc6f09e5dd43f823e625">pteros::Selection::get_resid</a></div><div class="ttdeci">std::vector&lt; int &gt; get_resid(bool unique=false) const</div><div class="ttdoc">Get vector of all resid's in selection.</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_a331c35d20439a56bd5986d14c53e12dd"><div class="ttname"><a href="classpteros_1_1Selection.html#a331c35d20439a56bd5986d14c53e12dd">pteros::Selection::xyz</a></div><div class="ttdeci">Eigen::Vector3f &amp; xyz(int ind)</div><div class="ttdoc">Extracts X,Y and Z for current frame.</div><div class="ttdef"><b>Definition:</b> selection.h:899</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_a5dda11576d03ccd8f5428ed18303ff4c"><div class="ttname"><a href="classpteros_1_1Selection.html#a5dda11576d03ccd8f5428ed18303ff4c">pteros::Selection::x</a></div><div class="ttdeci">float &amp; x(int ind)</div><div class="ttdoc">Extracts X for current frame.</div><div class="ttdef"><b>Definition:</b> selection.h:878</div></div>
<div class="ttc" id="aclasspteros_1_1Selection_html_ae34b009075510a23700132e477c2f5fe"><div class="ttname"><a href="classpteros_1_1Selection.html#ae34b009075510a23700132e477c2f5fe">pteros::Selection::select</a></div><div class="ttdeci">Selection select(std::string str)</div><div class="ttdoc">Sub-selections allow selecting atoms inside existing selection (narrowing or refining existing select...</div><div class="ttdef"><b>Definition:</b> selection.cpp:313</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">User manual</a></li>
    <li class="footer">Generated on Sat Jul 9 2022 15:59:59 for Pteros by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
