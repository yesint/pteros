<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pteros: C++ Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pteros.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pteros
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Molecular modeling library for human beings!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('cpptutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C++ Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#getting_started">Getting started</a></li>
<li class="level1"><a href="#selections">Selections</a><ul><li class="level2"><a href="#text_sel">Textual selections</a></li>
<li class="level2"><a href="#non_text_sel">Non-textual selections</a></li>
<li class="level2"><a href="#mod_sel">Modifying selections</a></li>
<li class="level2"><a href="#copy_assign">Copying and assigning selections</a></li>
</ul>
</li>
<li class="level1"><a href="#manip">Manipulating selections</a><ul><li class="level2"><a href="#transforms">Geometry transformations</a></li>
<li class="level2"><a href="#rmsd">RMS fitting and alignment</a></li>
</ul>
</li>
<li class="level1"><a href="#bindings">Python bindings</a></li>
<li class="level1"><a href="#hi_level">High-level facilities</a></li>
<li class="level1"><a href="#analysis_plugins">Very-high-level facilities</a><ul><li class="level2"><a href="#pure_python">Writing pure Python analysis plugin</a></li>
<li class="level2"><a href="#compiled">Writing compiled analysis plugin</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="getting_started"></a>
Getting started</h1>
<p>Suppose that the Pteros library is compiled and all linking requirements are satisfied. In order to start using Pteros in you program you need single include statement:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;pteros/pteros.h&quot;</span></div></div><!-- fragment --><p>This will include basic classes of the library. All classes and function of the Pteros library are defined inside "pteros" namespace. The following line will allow to omit repetitive "pteros::" prefix in your program:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepteros.html">pteros</a>;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>More advanced usage requires additional headers.</dd></dl>
<p>The fundamental objects in Pteros are <em>systems</em> and <em>selections</em>. System is what its name suggests - the whole molecular system with atoms and their coordinates (plus optional information about bonds, periodic box and force field parameters). The attributes and the coordinates of atoms are physically stored in the system. Typically the system is loaded from one or several files (such as PDB or GRO). The system can contain several sets of coordinates, called <em>frames</em>, which are typically loaded from trajectory files of MD simulations (such as XTC or DCD). The system can be created in two ways:</p>
<div class="fragment"><div class="line"><span class="comment">// 1)</span></div><div class="line">System  sys1; <span class="comment">// Empty system</span></div><div class="line">sys1.load(<span class="stringliteral">&quot;2lao.pdb&quot;</span>); <span class="comment">// Load data into system</span></div><div class="line"></div><div class="line"><span class="comment">// 2)</span></div><div class="line">System  sys2(<span class="stringliteral">&quot;2lao.pdb&quot;</span>); <span class="comment">// Read the structure file into the system immediately</span></div></div><!-- fragment --><p>The method <code>load</code> has reach set of additional options and could be called several times to add difference pieces of data from several structure and trajectory files. See <a class="el" href="core.html#advanced_load">Advanced loading with file handlers</a> for details.</p>
<p>Atoms and frames are stored inside the system are usually not accessed directly. The system is only a container for them, while all manipulations are done by means of <em>selections</em>.</p>
<h1><a class="anchor" id="selections"></a>
Selections</h1>
<p>Selection is a subset of atoms in the System. Selection does not hold any data, but merely point to particular group of atoms. There are several ways of creating a selection - from textual description, from the sequence of indexes, by using custom selection functions, etc. (see <a class="el" href="core.html#making_selections">here</a> for details). Every selection is associated with one and only one system. You can't select atoms from several systems simultaneously.</p>
<h2><a class="anchor" id="text_sel"></a>
Textual selections</h2>
<p>In order to create a selection from the textual dexcription you must supply the parent system and selection string. The selection syntax in Pteros is very similar to one used in <a href="http://www.ks.uiuc.edu/Research/vmd/">VMD</a>.</p>
<p>Instead of giving long and boring formal description of the selection syntax (available <a class="el" href="core.html#sel_lang">here</a>), let's learn it by example: </p><div class="fragment"><div class="line"><span class="comment">// Create a system</span></div><div class="line">System sys(<span class="stringliteral">&quot;some-protein.pdb&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Select everything</span></div><div class="line">Selection sel0 = sys(<span class="stringliteral">&quot;all&quot;</span>);</div><div class="line"><span class="comment">// Or just an empty pair of ()</span></div><div class="line">Selection sel0 = sys();</div><div class="line"></div><div class="line"><span class="comment">// Select by atom name(s)</span></div><div class="line">Selection sel1 = sys(<span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line">Selection sel2 = sys(<span class="stringliteral">&quot;name CA CB OA&quot;</span>); <span class="comment">// Selects all CA, CB and OA atoms</span></div><div class="line"></div><div class="line"><span class="comment">// Select by residue number. You can use ranges in two forms with &quot;-&quot; and with &quot;to&quot;.</span></div><div class="line">Selection sel3=sys(<span class="stringliteral">&quot;resid 3&quot;</span>); <span class="comment">// single residue number 3</span></div><div class="line">Selection sel4=sys(<span class="stringliteral">&quot;resid 1-25&quot;</span>); <span class="comment">// Residues from 1 to 25 inclusive</span></div><div class="line">Selection sel5=sys(<span class="stringliteral">&quot;resid 100 1-25 200 to 206&quot;</span>); <span class="comment">// Residues from 1 to 25, from 200 to 206 and also residue 100</span></div><div class="line"></div><div class="line"><span class="comment">// Select by atom index (starts from zero). You can also use ranges.</span></div><div class="line">Selection sel6=sys(<span class="stringliteral">&quot;index 3&quot;</span>);</div><div class="line">Selection sel7=sys(<span class="stringliteral">&quot;index 20 5 100-600 700 9 0 2&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Select by residue name(s)</span></div><div class="line">Selection sel8=sys(<span class="stringliteral">&quot;resname ALA&quot;</span>); <span class="comment">// Selects all ALA residues</span></div><div class="line">Selection sel9=sys(<span class="stringliteral">&quot;resname THR MET&quot;</span>); <span class="comment">// Selects all THR and MET residues</span></div><div class="line"></div><div class="line"><span class="comment">// Select by chain(s)</span></div><div class="line">Selection sel10=sys(<span class="stringliteral">&quot;chain A B&quot;</span>); <span class="comment">// Selects chains A and B</span></div><div class="line"></div><div class="line"><span class="comment">// Select by coordinates of atoms (arbitrary arithmetic expressions are supported)</span></div><div class="line">Selection sel11=sys(<span class="stringliteral">&quot;x&lt;10 and y&gt;z*4.5+x&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// This will select all atoms inside a cylinder aligned with Z axis with a radius of 2 Angstroms:</span></div><div class="line">Selection sel12=sys(<span class="stringliteral">&quot;x^2+y^2 &lt; 2^2&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Arbitraraly complex logic with AND, OR  and NOT could be used</span></div><div class="line">Selection sel13(sys,<span class="stringliteral">&quot;((name CA and resid 10 to 100) or (name CB and resname ALA)) or x^2&gt;y^2&quot;</span>);</div><div class="line">Selection sel14(sys,<span class="stringliteral">&quot;not (name CA and resid 10-100)&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Select all atoms, which are within given distance (in nm!) from another selection</span></div><div class="line">Selection sel15(sys,<span class="stringliteral">&quot;within 2.5 of (name CA and resname ALA)&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// The same as above, but takes care of periodic boundary conditions (try doing this in VMD. Good luck :) )</span></div><div class="line">Selection sel15periodic(sys,<span class="stringliteral">&quot;within 2.5 periodic of (name CA and resname ALA)&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Instead of &quot;periodic&quot; keyword you can use shorter &quot;pbc&quot;. &quot;nopbc&quot; and &quot;noperiodic&quot; could also be used but they are used by default and could be omitted.</span></div><div class="line"></div><div class="line"><span class="comment">// Within also takes &quot;noself&quot; keyword which excludes the central selection</span></div><div class="line"><span class="comment">// (those after &quot;of&quot;) from result:</span></div><div class="line">Selection sel15noself(sys,<span class="stringliteral">&quot;water and within 0.7 pbc noself of protein&quot;</span>); <span class="comment">// Select water around protein without protein itself</span></div><div class="line"></div><div class="line"><span class="comment">// Select whole residue if at least one atom from this residue is found in selection, enclosed into &quot;()&quot;</span></div><div class="line">Selection sel16(sys,<span class="stringliteral">&quot;by residue (name CA and resname ALA)&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Select using regular expressions. Will select all atoms with names staring with C - CA, CB, C1H, etc.</span></div><div class="line">Selection sel17(sys, <span class="stringliteral">&quot;name &#39;C.*&#39;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Select atoms within 0.5 nm of the point in space with coordinates {1.12, 4.56, 6.7}:</span></div><div class="line">Selection sel18(sys,<span class="stringliteral">&quot;distance point 1.12 4.56 6.7 &lt; 0.5&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Select atoms within 0.5 nm of the line, specified by two points {1.12, 4.56, 6.7} and {3.5 5.6 10.1}:</span></div><div class="line">Selection sel19(sys,<span class="stringliteral">&quot;distance vector 1.12 4.56 6.7 3.5 5.6 10.1 &lt; 0.5&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Select atoms within 0.5 nm of the plane, specified by the point {1.12, 4.56, 6.7} and the normal vector {0 1 1}</span></div><div class="line"><span class="comment">// accounting for periodic boundary conditions (pbc is handy equivalent to periodic):</span></div><div class="line">Selection sel19(sys,<span class="stringliteral">&quot;distance pbc plane 1.12 4.56 6.7 0 1 1 &lt; 0.5&quot;</span>);</div></div><!-- fragment --><p>Textual selections are "smart" in a way that selection text is analysed and optimized in numerous ways before evaluation. If selection depends on the <em>coordinates</em> of atoms it updates automatically if the coordinates change: </p><div class="fragment"><div class="line"><span class="comment">// Load structure</span></div><div class="line">System s(<span class="stringliteral">&quot;some-protein.pdb&quot;</span>);</div><div class="line"><span class="comment">// Load trajectory with multiple frames</span></div><div class="line">s.load(<span class="stringliteral">&quot;traj.xtc&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Create selection depending on coordinates</span></div><div class="line">Selection sel(s,<span class="stringliteral">&quot;x&gt;10&quot;</span>); <span class="comment">// By default points to frame 0</span></div><div class="line">sel.set_frame(1);</div><div class="line"><span class="comment">// Now points to frame 1. Coordinates of atoms change but selection</span></div><div class="line"><span class="comment">// is smart and updates automatically!</span></div></div><!-- fragment --><h2><a class="anchor" id="non_text_sel"></a>
Non-textual selections</h2>
<p>It is also possible to make a selection from the pair of indexes or the pair of iterators of some integer sequence:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> ind1 = 10;</div><div class="line"><span class="keywordtype">int</span> ind2 = 20;</div><div class="line">Selection sel20(sys,ind1,ind2); <span class="comment">// Selects all indexes from 10 to 20 inclusive</span></div><div class="line"></div><div class="line">vector&lt;int&gt; ind = {5,10,34,1,4,15};</div><div class="line">Selection sel21(sys,ind.begin(),ind.end()); <span class="comment">// Select by iterators to integer container</span></div></div><!-- fragment --><p>Finally, if you want to implement really complex logic of selecting atoms you can use selection with callbacks:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a callback function which includes complex selection logic</span></div><div class="line"><span class="comment">// It takes a system, a number of target frame and the vector of selected indexes</span></div><div class="line"><span class="comment">// which have to be filled. These indexes point to selected atoms</span></div><div class="line"><span class="keywordtype">void</span> sel_func(<span class="keyword">const</span> System&amp; sys,<span class="keywordtype">int</span> fr,std::vector&lt;int&gt;&amp; ind){</div><div class="line">    <span class="comment">// Some complex logic which fills ind with values goes here</span></div><div class="line">    <span class="comment">// Just for example we selecting all atoms with x&gt;5</span></div><div class="line">    ind.clear();</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;sys.num_atoms();++i)</div><div class="line">        <span class="keywordflow">if</span>(sys.XYZ(i,fr)(0)&gt;5.0) ind.push_back(i);</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">System s(<span class="stringliteral">&quot;struct.pdb&quot;</span>);</div><div class="line">Selection sel(s, &amp;sel_func); <span class="comment">// Callback function is called to fill selection</span></div></div><!-- fragment --><h2><a class="anchor" id="mod_sel"></a>
Modifying selections</h2>
<p>You can also create empty selections and populate them later using modify() methods: </p><div class="fragment"><div class="line">Selection sel2; <span class="comment">// Empty selection, not associated with the system</span></div><div class="line">Selection sel3(sys); <span class="comment">// Selection bounded to system sys, but selection text is not yet specified</span></div><div class="line"></div><div class="line"><span class="comment">// Now populate these selections</span></div><div class="line">sel2.set_system(sys); <span class="comment">// Set system first</span></div><div class="line">sel2.modify(<span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line"></div><div class="line">sel3.modify(<span class="stringliteral">&quot;name CB&quot;</span>); <span class="comment">// The system was set already</span></div><div class="line"></div><div class="line"><span class="comment">// You can reassign selection to another system if you want:</span></div><div class="line">sel3.set_system(other_sys); <span class="comment">// This clears selection...</span></div><div class="line">sel3.modify(<span class="stringliteral">&quot;name CB&quot;</span>); <span class="comment">// ...so we need to create it again</span></div></div><!-- fragment --><p>Different <code>modify()</code> methods exist, which correspond to other types of selections - for the pair of indexes, for the pair of iterators, for callback function, etc.</p>
<h2><a class="anchor" id="copy_assign"></a>
Copying and assigning selections</h2>
<p>Selections could be copyed and assigned, particularly it is possible to place them to STL containers: </p><div class="fragment"><div class="line">vector&lt;Selection&gt; vec;</div><div class="line">Selection sel(sys,<span class="stringliteral">&quot;all&quot;</span>);</div><div class="line">vec.push_back(sel);</div><div class="line"></div><div class="line"><span class="comment">// Make a vector of 10 empty selections</span></div><div class="line">vector&lt;Selection&gt; vec10(10);</div><div class="line"><span class="comment">// Populate some of them</span></div><div class="line">vec10[5].set_system(sys);</div><div class="line">vec10[5].modify(<span class="stringliteral">&quot;resname ALA&quot;</span>);</div><div class="line">vec10[6].set_system(sys);</div><div class="line">vec10[6].modify(<span class="stringliteral">&quot;not name O&quot;</span>);</div></div><!-- fragment --><p>If assigning one selection to another, the deep copy of the selection (not just a reference!) is created.</p>
<div class="fragment"><div class="line">Selection s1(sys);</div><div class="line">Selection s2(sys);</div><div class="line">s1 = s2; <span class="comment">// s1 is a deep copy of s2. Modifications to s1 do not change s2.</span></div></div><!-- fragment --><p>The systems are also copyable, but with one important twist - associated selections are not copyed with the parent system.</p>
<h1><a class="anchor" id="manip"></a>
Manipulating selections</h1>
<p>We can do a lot of different things with selections. Let's start from obtaining residue names of all selected atoms as an STL vector:</p>
<div class="fragment"><div class="line">vector&lt;string&gt; res_names = sel1.get_resname();</div></div><!-- fragment --><p>We can also obtain any property of particular selected atom with very simple syntax. For example let's print the chain and the resid of the first atom in selection:</p>
<div class="fragment"><div class="line">cout &lt;&lt; sel1.Chain(0) &lt;&lt; endl;</div><div class="line">cout &lt;&lt; sel1.Resid(0) &lt;&lt; endl;</div></div><!-- fragment --><p>Note that first atom in <em>selection</em> is <b>not</b> the first atom in the system! If you want to know the index of this atom in the system you should do</p>
<div class="fragment"><div class="line">cout &lt;&lt; sel1.Index(0) &lt;&lt; endl; <span class="comment">//May print &quot;1328&quot;. The first atom in selection is in fact the atom 1328 in the system</span></div></div><!-- fragment --><p>In fact the code "sel1.Chain(0)" above is an equivalent of verbose expression</p>
<div class="fragment"><div class="line"><span class="comment">// Just an example, will not compile!</span></div><div class="line">cout &lt;&lt; sys.atoms[sel1.index[0]].chain;</div></div><!-- fragment --><p>This fragment will not compile because Selection::index is private, but in any case the shorthand function Selection::Chain() simplifies the things a lot. Such shorthand functions are inlined, thus in principle there is no performance loss. Other atom attributes could also be accessed by means of such functions with the name, which coincide with the attribute name, but with the capital first letter (Name(i), Chain(i), Index(i), X(i), etc.). The main attributes of the atoms are:</p><ul>
<li><b>name</b> - the name of atom in PDB file (such as "CA")</li>
<li><b>resid</b> - the number of residue (an integer). Unique within each chain.</li>
<li><b>resindex</b> - Unique index of the residue in the whole system, even is multiple chains are present.</li>
<li><b>resname</b> - the name of the residue in 3-letters code (such as "ALA" or "GLY")</li>
<li><b>chain</b> - the chain in PDB file (single character, such as "A")</li>
<li><b>tag</b> - arbitrary textual tag (often called "segment" in CHARMM, NAMD or VMD)</li>
<li><b>mass</b> - the mass of the atom in atomic units</li>
<li><b>charge</b> - atomic charge (only assigned correctly if MD topology is loaded)</li>
<li><b>beta</b> - the B-factor in PDB file</li>
<li><b>occupancy</b> - the occupancy in PDB file</li>
</ul>
<p>Now let's play with the coordinates of atoms. First of all let's load molecular dynamics trajectory into the system: </p><div class="fragment"><div class="line">System s(<span class="stringliteral">&quot;some-protein.pdb&quot;</span>);</div><div class="line">s.load(<span class="stringliteral">&quot;trajectory.xtc&quot;</span>);</div><div class="line">Selection sel1(<span class="stringliteral">&quot;name CA&quot;</span>);</div></div><!-- fragment --><p>The trajectory should contain the same number of atoms as the system. The XTC, TRR and DCD trajectory files are now supportd.</p>
<p>It is also possible to read only certain portion of trajectory, say between frames 10 and 100: </p><div class="fragment"><div class="line">System s(<span class="stringliteral">&quot;some-protein.pdb&quot;</span>);</div><div class="line">s.load(<span class="stringliteral">&quot;trajectory.xtc&quot;</span>,10,100);</div></div><!-- fragment --><p>Selections are always born pointing to the frame 0 (frame count starts from zero). Let's make selection point to the frame 3:</p>
<div class="fragment"><div class="line">sel1.set_frame(3);</div></div><!-- fragment --><p>Now we can obtain the coordinate of particular atom <em>i</em> for the frame 3:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> x_coord = sel1.X(i);</div></div><!-- fragment --><p>or the coordinates of all atoms in selection for frame 3 as:</p>
<div class="fragment"><div class="line">vector&lt;float&gt; all_x_coords = sel1.get_x();</div></div><!-- fragment --><p>It is also possible to get coordinates of any frame by supplying second parameter: </p><div class="fragment"><div class="line"><span class="comment">// Copy all coordinates of atom 10 for frame 3 to atom 20 for frame 5</span></div><div class="line">sel1.XYZ(20,5) = sel1.XYZ(10,3);</div></div><!-- fragment --><p>Another way of getting the properties of atoms and coordinates in selection is using the indexing syntax: </p><div class="fragment"><div class="line">cout &lt;&lt; sel1[0].Resid() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sel1[3].XYZ(10) &lt;&lt; endl;</div></div><!-- fragment --><p>This code will output resid of the atom 0 and the coordinates of atom 3 for frame 10. Usually indexing syntax is less convenient and more verbose, however it has an big advantage of working in the iterator-based or range-based loops: </p><div class="fragment"><div class="line"><span class="comment">// Iterator-based loop:</span></div><div class="line"><span class="keywordflow">for</span>(Selection::iterator it=sel1.begin(); it!=sel1.end(); it++){</div><div class="line">  cout &lt;&lt; it-&gt;Resid() &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Range-based C++11 for loop:</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; at: sel1){</div><div class="line">  cout &lt;&lt; at.Resid() &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>One can also duplicate frames, copy one frame to the other and delete frames. Note that this is done by the methods of System class: </p><div class="fragment"><div class="line">System sys(<span class="stringliteral">&quot;some-protein.pdb&quot;</span>);</div><div class="line"><span class="comment">// Duplicate frame 4 (copy becomes the last frame)</span></div><div class="line">sys.frame_dup(4);</div><div class="line"><span class="comment">// Copy coordinates of this duplicated frame to frame 1</span></div><div class="line">sys.frame_copy(sys.num_frames()-1, 1); <span class="comment">// Note the usage of num_frames() to get the nuber of frames in the system</span></div></div><!-- fragment --><h2><a class="anchor" id="transforms"></a>
Geometry transformations</h2>
<p>Pteros provides reach set of geometry transformation functions. Transformation applied to selection will immediately take effect on all selections, which overlap with given selection. Let's look at some examples:</p>
<div class="fragment"><div class="line"><span class="comment">// Translate selection by given vector</span></div><div class="line">Vector3f dir(1.0, 3.4, -4.5);</div><div class="line">sel1.translate(dir);</div><div class="line"></div><div class="line"><span class="comment">// Rotate selection around axis X (axis 0) by some angle (in radians) relative to the center of masses</span></div><div class="line">sel1.rotate(0,0.2);</div><div class="line"></div><div class="line"><span class="comment">// Rotate selection around axis Y (axis 1) by some angle (in radians) relative to the given pivot point</span></div><div class="line">Vector3f pivot(10.0, 20.0, 30.0);</div><div class="line">sel1.rotate(1,-0.1,pivot);</div><div class="line"></div><div class="line"><span class="comment">// Rotate selection around given vector, by some angle and relative to given point</span></div><div class="line">Vector3f axis(0.0, 4.0, -2.0);</div><div class="line">sel1.rotate(axis,0.5,pivot);</div></div><!-- fragment --><h2><a class="anchor" id="rmsd"></a>
RMS fitting and alignment</h2>
<p>It is very easy to compute the RMSD between two selection of the same size (they can belong to different systems): </p><div class="fragment"><div class="line">Selection sel1(sys1,<span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line">Selection sel2(sys2,<span class="stringliteral">&quot;name CB&quot;</span>);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;RMSD=&quot;</span> &lt;&lt; rmsd(sel1,sel2) &lt;&lt; endl;</div></div><!-- fragment --><p>We can also do this for arbitrary frames: </p><div class="fragment"><div class="line">Selection sel1(sys1,<span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line">Selection sel2(sys2,<span class="stringliteral">&quot;name CB&quot;</span>);</div><div class="line"><span class="comment">// RMSD between frame 0 of the first selection and frame 1 of the second one</span></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;RMSD=&quot;</span> &lt;&lt; rmsd(sel1, 0, sel2, 1) &lt;&lt; endl;</div></div><!-- fragment --><p>It is possible to compute RMSD for different frame of the same selection: </p><div class="fragment"><div class="line">Selection sel1(sys1,<span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line"><span class="comment">// RMSD between frames 0 and 1</span></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;RMSD=&quot;</span> &lt;&lt; sel1.rmsd(0,1) &lt;&lt; endl;</div></div><!-- fragment --><p>In order to do RMSD fitting of two selections of the same size it enough to write: </p><div class="fragment"><div class="line">Selection sel1(sys1,<span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line">Selection sel2(sys2,<span class="stringliteral">&quot;name CB&quot;</span>);</div><div class="line"><span class="comment">// Fit selection sel1 to sel2</span></div><div class="line">fit(sel1,sel2);</div></div><!-- fragment --><p>However, the most common situation is when you are fitting together, say, Ca atoms, but need to rotate the whole protein according to this fitting. This is accomplished by computing fitting transformation first and then applying it: </p><div class="fragment"><div class="line">Selection sel1(sys,<span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line"><span class="comment">// Compute a fit transform for fitting frame 1 to frame 3</span></div><div class="line">Affine3f trans = sel1.fit_transform(1,3);</div><div class="line"><span class="comment">// And apply it to the whole protein</span></div><div class="line">Selection(sys,<span class="stringliteral">&quot;all&quot;</span>).apply_transform(trans);</div><div class="line"><span class="comment">// The perevious line shows how to create a temporary selection &quot;on the fly&quot;.</span></div></div><!-- fragment --><h1><a class="anchor" id="bindings"></a>
Python bindings</h1>
<p>Although Pteros is a C++ library, many molecular analysis tasks require writing simple "throw-away" scripts without edit-compile-run overhead of C++. Python bindings serve this purpose in Pteros. In addition to this end-user application Python bindings are also vital part of the <a class="el" href="cpptutorial.html#analysis_plugins">Very-high-level facilities</a> system.</p>
<p>Bindings are described in a <a href="python/_build/html/index.html">dedicated documentation page</a>.</p>
<h1><a class="anchor" id="hi_level"></a>
High-level facilities</h1>
<p>Although System and Selection classes already provide quite high-level tools for building custom analysis programs, Pteros contains even more advanced facilities for rapid implementation of complex analysis algorithms. When you build your custom analysis program, it is usually painful to implement the following things:</p><ul>
<li>Read only specified range of frames from trajectory based on time or frame number.</li>
<li>Read the trajectory, stored by pieces in several files.</li>
<li>Read very large trajectory, which doen't fit into the memory frame by frame.</li>
<li>Implement parallel execution of several analysis tasks, to keep all processor cores busy.</li>
<li>Implement processing of the command line arguments, which set all options of trajectory processing and represent custom flags for your analysis.</li>
</ul>
<p>It is necessary to emphasize an importance of parallel processing. MD trajectories are often huge (up to ~100Gb) and reading them from disk tipically takes many minutes, especially if the storage is not local. If you have 5 different anaysis tasks, which should be applied to the same trajectory it is very wasteful to run them sequntially and to read the whole trajectory five times. It is much more logical to read the trajectory only ones and execute all your tasks in parallel for each frame. By doing this you will also utilize the power of you modern multi-core processor effectively.</p>
<p>All these routine operations in Pteros are incapsulated into the Trajectory_processor class. The logic of using this class is the following. You supply it with the set of options (the trajectory to read, which frames to include into the analysis, etc). In addition you create a number of Consumer objects, which represent separated analysis tasks, and connect them to the Trajectory_processor. After that you run the processor. It launches all supplied tasks in separate parallel threads, read the trajectory frame by frame and passes the frames to each of the tasks for user-defined processing.</p>
<p>Let's write a simple example of computing average minimal and maximal coordinates in selection along the trajectory using the power of Trajectory_processor. First of all we need to subclass a Consumer class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Our_task: <span class="keyword">public</span> Consumer {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        <span class="comment">// Constructor</span></div><div class="line">        Our_task(Trajectory_processor* pr, <span class="keywordtype">string</span> sel_str): Consumer(pr){</div><div class="line">                <span class="comment">// set selection text</span></div><div class="line">                sel_text = sel_str;</div><div class="line">        }</div><div class="line"><span class="keyword">protected</span>:      </div><div class="line">        <span class="comment">// Inherited methods from Consumer:</span></div><div class="line">        <span class="comment">// Called immediately before first frame is processed</span></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> pre_process();</div><div class="line">        <span class="comment">// Called immediately after last frame is processed</span></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> post_process(<span class="keyword">const</span> Frame_info&amp; info);</div><div class="line">        <span class="comment">// Called each time new frame arrives.</span></div><div class="line">        <span class="comment">// This frame is stored in system.traj[0]</span></div><div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> process_frame(<span class="keyword">const</span> Frame_info&amp; info);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Variables, which are specific for our analysis</span></div><div class="line">        Vector3f min_average, max_average;</div><div class="line">        <span class="keywordtype">string</span> sel_text;</div><div class="line">        Selection sel;</div><div class="line">}</div></div><!-- fragment --><p>All logic of our analysis should be implemented in three virtual methods: pre_process(), process_frame() and post_process(). The names are self-explanatory. Let's implement them:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> pre_process(){</div><div class="line">        <span class="comment">// Prepare our min and max variables for computing averages</span></div><div class="line">        min_average.fill(0.0);</div><div class="line">        max_average.fill(0.0);  </div><div class="line">        sel.modify(system,sel_text);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> process_frame(<span class="keyword">const</span> Frame_info&amp; info){        </div><div class="line">        <span class="comment">// Currently loaded frame is stored in internal system in frame 0.</span></div><div class="line">        <span class="comment">// Our selection already points to it by default.</span></div><div class="line">        <span class="comment">// Compute minimal and maximal values</span></div><div class="line">        Vector3f min,max;</div><div class="line">        sel.minmax(min,max); <span class="comment">//Using minmax() method of selection class</span></div><div class="line">        <span class="comment">// Add to averages</span></div><div class="line">        min_average += min;</div><div class="line">        max_average += max;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> post_process(<span class="keyword">const</span> Frame_info&amp; info){</div><div class="line">        <span class="comment">// Here we make use of Frame_info object to get the time range of processing</span></div><div class="line">        min_average /= (info.last_time-info.first_time);</div><div class="line">        max_average /= (info.last_time-info.first_time);</div><div class="line">        <span class="comment">// Transpose is used to print a vector in one line instead of column of numbers</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Averaged minimal value: &quot;</span> &lt;&lt; min_average.transpose() &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Averaged maximal value: &quot;</span> &lt;&lt; max_average.transpose() &lt;&lt; endl;  </div><div class="line">}</div></div><!-- fragment --><p>Now we can write a main program for our small analysis utility: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;pteros/analysis/trajectory_processor.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;path to Our_task definition&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacepteros.html">pteros</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]){</div><div class="line">        <span class="comment">// Create container for command-line options</span></div><div class="line">        <a class="code" href="classpteros_1_1Options.html">Options</a> options;</div><div class="line">        <span class="comment">// Parse command line</span></div><div class="line">        parse_command_line(argc,argv,options);</div><div class="line">        <span class="comment">// Create Trajectory processor and pass options to it</span></div><div class="line">        Trajectory_processor proc(options);</div><div class="line">        <span class="comment">// Create our analysis task and connect it to processor</span></div><div class="line">        Our_task task1(&amp;proc, <span class="stringliteral">&quot;name CA&quot;</span>);</div><div class="line">        <span class="comment">// Create another task</span></div><div class="line">        Our_task task2(&amp;proc, <span class="stringliteral">&quot;name CB&quot;</span>);</div><div class="line">        <span class="comment">// And another one</span></div><div class="line">        Our_task task3(&amp;proc, <span class="stringliteral">&quot;within 2.5 of resid 1 to 100&quot;</span>);</div><div class="line">        <span class="comment">// Run processor!</span></div><div class="line">        proc.compute();</div><div class="line">}</div></div><!-- fragment --><p>Now three tasks, operating on different selections will run in parallel while reading the trajectory. But wait, what trajectory we are going to read? This is specified at run time by the command line arguments:</p>
<div class="fragment"><div class="line">./our_program -f some-protein.pdb traj-part1.xtc traj-part2.xtc -b 14fr -e 250ps</div></div><!-- fragment --><p>In our case we specify -f, -b and -e arguments, which are absorbed internally by Trajectory_processor. Trajectory_processor looks at the list of files cpecified after -f and finds a structure file (some-protein.pdb in our case). This file is loaded into the "system" variable of all our tasks. Then Trajectory_processor reads all trajectories one by one in order of appearance and calls our task for frame processing. Processing starts at frame 14 and ends when the time stamp in current frame becomes larger then 250 ps. All this complex logic is completely incapsulated by Trajectory_processor class, which saves you a lot of time.</p>
<p>As you noticed, we hard-coded selection texts in out code. Let's do our program more flexible. We will modify it to take multiple additional arguments like this: </p><div class="fragment"><div class="line">./our_program -f some-protein.pdb traj-part1.xtc traj-part2.xtc -b 14fr -e 250ps -sel &quot;name CA&quot; &quot;name CB&quot; &quot;resid 1-15&quot;</div></div><!-- fragment --><p>This is surprisingly simple:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]){</div><div class="line">        <span class="comment">// Create container for command-line options</span></div><div class="line">        Options options;</div><div class="line">        <span class="comment">// Parse command line</span></div><div class="line">        parse_command_line(argc,argv,options);</div><div class="line">        <span class="comment">// Create Trajectory processor;</span></div><div class="line">        Trajectory_processor proc(options);</div><div class="line">        </div><div class="line">        <span class="comment">// Container for our tasks</span></div><div class="line">        vector&lt;shared_ptr&lt;Our_task&gt; &gt; tasks;</div><div class="line">        </div><div class="line">        <span class="comment">// Get all values from -sel key and cycle over them</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; sel_text: options(<span class="stringliteral">&quot;sel&quot;</span>).as_strings()){               </div><div class="line">                <span class="comment">// Create task</span></div><div class="line">                shared_ptr&lt;Our_task&gt; task(&amp;proc, sel_text);</div><div class="line">                tasks.push_back(task);</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Run processor!</span></div><div class="line">        proc.compute();</div><div class="line">}</div></div><!-- fragment --><p>In fact we only need three lines to process our additional options! </p><dl class="section note"><dt>Note</dt><dd>Trajectory_processor doesn't own the consumers, so we need to save them in a vector to ensure that they will not be destructed immediately.</dd></dl>
<h1><a class="anchor" id="analysis_plugins"></a>
Very-high-level facilities</h1>
<p>Pteros provides even higher level facilities for developing custom trajectory analysis algorithms - the analysis plugins. The analysis plugin is a class with very simple interface derived from Consumer, which runs in parallel during reading the trajectory. In contrast to Consumer analysis plugins are loaded and executed by dedicated driver program, so you don't need to bother with initialization of Trajectory_processor, passing parameters and other 'housholding' code. The most exciting thing about analysis plugins is that they could be written either in C++ or pure Python using almost identical API and intergrated seamlessly. </p><dl class="section note"><dt>Note</dt><dd>Plugins written in C++ could also be compiled as the separate stand-alone programs, which doesn't require Python to run. Just add <b>-DSTANDALONE_PLUGINS="ON"</b> option when compiling your plugin.</dd></dl>
<p>C++ analysis plugins run at <em> the same speed </em> as manually written programs, which use Trajectory_processor and Consumer - there is no run-time overhead (except initial searching and loading of plugins, which is usually neglegible). The driver script only connects the consumers with Trajectory_processor from Python side and after that no Python code is evaluated at all.</p>
<p>Pure Python tasks are, of course, limited by the speed of Python interpreter but they are extremely easy to write and to modify. In general pure Python tasks, which mostly call compiled Pteros methods are also very fast.</p>
<p>In the /bin directory of your pteros installation you can find pteros_analysis.py executable Python script, which is the driver for analysis plugins. All plugins (both C++ and Python) are stored in <b>python/pteros_analysis_plugins</b> directory. Any shared library (*.so) or python file (*.py), which appear there is treated as a plugin and could be loaded by the driver.</p>
<p>The driver script is called like this (splitted by several lines for clarity): </p><div class="fragment"><div class="line">python pteros_analysis.py \</div><div class="line">-f \</div><div class="line"> structure-file.pdb \</div><div class="line"> some-trajectory.xtc \</div><div class="line"> -b 0fr -e 100fr \</div><div class="line">-task center -selection &quot;name CA&quot; -mass_weighted true \</div><div class="line">-task sample1 -val 1 \</div><div class="line">-task sample2 -val 2 \</div><div class="line">-task user_script -plugin_file script1.py -val 42</div></div><!-- fragment --><p>The driver loads specified structure file and reads provided trajectory frame by frame in the given range of frames. On each frame all specified tasks are called.</p>
<ul>
<li>Compiled C++ tasks are executed in separate threads <em>completely in parallel</em>.</li>
<li>All Python tasks are executed <em>sequencially</em> in one dedicated thread.</li>
</ul>
<p>Thus all Python tasks run in parallel with C++ tasks but sequentially in respect to each other (this is an unfortunate limitation of the Python multithreading model). In practice you'll unlikely run many time consuming Python tasks simultaneously, so this should not be a serious performance limitation. In any case if the execution speed becomes a problem it is better to implement the plugin in C++.</p>
<p>Passing the parameter <b>-plugin_file</b> to any task allows loading plugins from any non-standard location by the relative or absolute path.</p>
<p>You are free to run multiple instances of the same task with different parameters </p><div class="fragment"><div class="line">-task center -selection &quot;name CA&quot; -mass_weighted true \</div><div class="line">-task center -selection &quot;name CB CC&quot; -mass_weighted false \</div></div><!-- fragment --><p>all of them will be executed separately and will not interfere with each other.</p>
<h2><a class="anchor" id="pure_python"></a>
Writing pure Python analysis plugin</h2>
<p>Let's write simple pure Python analysis plugin, which computes center of masses of given selection. Put the following code into the file example_plugin.py and place it into the directory python/pteros_analysis_plugins of your Pteros installation </p><div class="fragment"><div class="line"><span class="keyword">from</span> pteros <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="keyword">class </span>Task:             </div><div class="line">        <span class="keyword">def </span>pre_process(self):</div><div class="line">                self.sel_text = self.options(<span class="stringliteral">&quot;selection&quot;</span>).as_string()</div><div class="line">                self.use_mass = self.options(<span class="stringliteral">&quot;mass_weighted&quot;</span>,<span class="stringliteral">&quot;False&quot;</span>).as_bool()</div><div class="line">                self.sel = Selection(self.system, self.sel_text )</div><div class="line">                <span class="keywordflow">print</span> <span class="stringliteral">&quot;Working on selection &#39;%s&#39;&quot;</span> % self.sel.get_text()</div><div class="line">                                </div><div class="line">        <span class="keyword">def </span>process_frame(self,info):                </div><div class="line">                <span class="keywordflow">print</span> <span class="stringliteral">&quot;Frame &quot;</span>, info.absolute_frame, <span class="stringliteral">&quot; time &quot;</span>, info.absolute_time</div><div class="line">                <span class="keywordflow">print</span> <span class="stringliteral">&quot;There are %i atoms in selection&quot;</span> % self.sel.size()</div><div class="line">                <span class="keywordflow">print</span> <span class="stringliteral">&quot;Selection center: &quot;</span>, self.sel.center(self.use_mass)</div><div class="line"></div><div class="line">        <span class="keyword">def </span>post_process(self,info):</div><div class="line">                <span class="keywordflow">print</span> <span class="stringliteral">&quot;Finished!&quot;</span></div></div><!-- fragment --><p>Any Python plugin should define a class Task with three methods: pre_process(), post_process() and process_frame(). The signatures of the methods are evident from the code. Such class gets "magic" variables <b>system</b>, <b>label</b> and <b>options</b>. The <b>system</b> variable is a reference to the underlying system object, while <b>label</b> is a textual label "\&lt;TaksName\&gt;_id\&lt;N\&gt;", where TaskName is the name of analysis plugin and N is the unique number of the task. Label is handy when you need to get a unique name of the output file, which will never clash with the output of other tasks, which are running in parallel.</p>
<p>The variable <b>options</b> contains the options, which corresponds <em>to this particular task</em>. We extract the options selection and mass_weighted using it.</p>
<p>The rest of the code is self-explanatory.</p>
<h2><a class="anchor" id="compiled"></a>
Writing compiled analysis plugin</h2>
<p>Let us implement the same plugin in C++. It will look almost the same and has very small syntactic overhead:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PLUGIN_NAME: <span class="keyword">public</span> Compiled_plugin_base {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PLUGIN_NAME(Trajectory_processor* pr, Options_tree* opt): Compiled_plugin_base(pr,opt) {</div><div class="line">    }</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keywordtype">void</span> pre_process(){</div><div class="line">        <span class="keywordtype">string</span> sel_text = options(<span class="stringliteral">&quot;selection&quot;</span>).as_string();</div><div class="line">        use_mass = options(<span class="stringliteral">&quot;mass_weighted&quot;</span>,<span class="stringliteral">&quot;false&quot;</span>).as_bool();        </div><div class="line">        sel.modify(system,sel_text);</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Working on selection &quot;</span> &lt;&lt; sel.get_text() &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> process_frame(<span class="keyword">const</span> Frame_info &amp;info){        </div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; sel.size() &lt;&lt; <span class="stringliteral">&quot; atoms in selection&quot;</span> &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Frame &quot;</span> &lt;&lt; info.absolute_frame</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot; time &quot;</span> &lt;&lt; info.absolute_time &lt;&lt; endl;</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Selection center: &quot;</span> &lt;&lt; sel.center(use_mass).transpose() &lt;&lt; endl;        </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> post_process(<span class="keyword">const</span> Frame_info &amp;info){</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Finished&quot;</span> &lt;&lt; endl;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Selection sel;</div><div class="line">    <span class="keywordtype">bool</span> use_mass;</div><div class="line">};</div><div class="line"></div><div class="line">CREATE_COMPILED_PLUGIN(PLUGIN_NAME)</div></div><!-- fragment --><p>We inherit a class from <b>Compiled_plugin_base</b> and override the same methods pre_process(), post_process() and process_frame(). In C++ we need to put an explicit constructor, which will initialize the base class. The rest of the code is almost 1-to-1 translation of the Python example given above.</p>
<p>The crucial point is the macro <b>CREATE_COMPILED_PLUGIN(PLUGIN_NAME)</b>, which does all the magic for us. Behind the scene it creates the code for compiled Python extension module. After compilation and linking we get <b>center.so</b> file, which is loaded by the driver program at the same way as our pure Python plugin.</p>
<dl class="section note"><dt>Note</dt><dd>In the case of the stand-alone plugin this macro will create an independent <b>pteros_center</b> executable instead.</dd></dl>
<p>The macro PLUGIN_NAME comes from the CMake build script, but you can define your own name in the code (in this case you whould also make sure that the build system produces shared library with appropriate name!).</p>
<p>The simplest way to build and install your plugin is using the template CMake project located at the /template_plugin directory of the Pteros source tree. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Oct 14 2021 12:40:07 for Pteros by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
