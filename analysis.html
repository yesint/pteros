<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pteros: Analysis of trajectories</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pteros.jpeg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pteros
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Molecular modeling library for human beings!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('analysis.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Analysis of trajectories </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#anal_concepts">Asynchronous parallel trajectory processing in Pteros</a></li>
<li class="level1"><a href="#processors_consumers">Trajectory reader and analysis tasks</a><ul><li class="level2"><a href="#task_types">Serial and parallel tasks</a><ul><li class="level3"><a href="#par_select">Selections in parallel tasks</a></li>
</ul>
</li>
<li class="level2"><a href="#options">Processing command-line options</a><ul><li class="level3"><a href="#suffix">Value suffixes</a></li>
</ul>
</li>
<li class="level2"><a href="#frame_info">Understanding frame metadata</a></li>
<li class="level2"><a href="#magic_vars">&quot;Magic variables&quot; in analysis tasks</a></li>
<li class="level2"><a href="#jump">Removing jumps over periodic boundaries</a></li>
</ul>
</li>
<li class="level1"><a href="#plugins">Analysis plugins</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="anal_concepts"></a>
Asynchronous parallel trajectory processing in Pteros</h1>
<p>Although <a class="el" href="classpteros_1_1System.html" title="The system of atoms. ">System</a> and <a class="el" href="classpteros_1_1Selection.html" title="Selection class. ">Selection</a> classes already provide quite high-level tools for building custom analysis programs, Pteros contains even more advanced facilities for rapid implementation of complex analysis algorithms. When you build your custom analysis program, it is usually painful and repetitive to implement the following things:</p><ul>
<li>Read only specified range of frames from trajectory based on time stamp or frame number.</li>
<li>Read the trajectory, stored by pieces in several files.</li>
<li>Read very large trajectory, which doen't fit into the memory frame by frame.</li>
<li>Implement parallel execution of several analysis tasks, to keep all processor cores busy.</li>
<li>Implement processing of the command line arguments, which set all options of trajectory processing and represent custom flags for your analysis.</li>
</ul>
<p>It is necessary to emphasize an importance of parallel processing. MD trajectories are often huge (up to ~100Gb) and reading them from disk tipically takes many minutes, especially if the storage is slow or even non-local. If you have 5 different anaysis tasks, which should be applied to the same trajectory it is very wasteful to run them sequntially and to read the whole trajectory five times. It is much more logical to read the trajectory only ones and execute all your tasks in parallel for each frame. By doing this you will also utilize the power of you modern multi-core processor effectively.</p>
<p>Another scenario is the analysis task, which does not depend on frame processing order. Typical example is averaging of some property over the frames. In such case it is tempting to spawn several instances of analys task, each running in parallel in its own thread, and dispatch frames to them from the shared queue without any particular order. This again utilizes all cores of your processor and can make the analysis much faster.</p>
<p>All these routine operations in Pteros are incapsulated into the Trajectory_reader class. The logic of using this class is the following. You supply it with the set of options (the trajectory to read, which frames to include into the analysis, etc). In addition you create a number of task objects, which represent separated analysis tasks, and connect them to the Trajectory_reader. After that you run the reader. It launches all supplied tasks in separate parallel threads (or spawns many instances of the parallel task), reads the trajectory frame by frame in yet another thread and passes the frames to each of the tasks for user-defined processing. In such scenario the speed of trajectory processing is limited by either the slowest task or the trajectory file IO (whatever is slower).</p>
<p>Although the framework of trajectory reader and tasks is a high-level concept by itself it is used to provide even higher-level abstractions - the <a class="el" href="analysis.html#plugins">Analysis plugins</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Although Trajectory_reader and tasks are exposed to Python the prefered way of using them in Python is by writing analysis plugins.</dd></dl>
<h1><a class="anchor" id="processors_consumers"></a>
Trajectory reader and analysis tasks</h1>
<p>Trajectory_reader class incapsulates all low-level details of reading trajectories including reading intervals of frames or times, skipping frames, etc. Its typical usage is the following: </p><div class="fragment"><div class="line"><span class="comment">// Create serial analysis task using corresponding macro</span></div><div class="line"><span class="comment">// The details will be covered later</span></div><div class="line"></div><div class="line">TASK_SERIAL(My_task)</div><div class="line">    <span class="keywordtype">void</span> pre_process()<span class="keyword"> override </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> process_frame(<span class="keyword">const</span> Frame_info&amp; info)<span class="keyword"> override </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> post_process(<span class="keyword">const</span> Frame_info&amp; info)<span class="keyword"> override </span>{ ...  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv){</div><div class="line">    <span class="comment">// Represents built-in and custom command line options</span></div><div class="line">    Options reader_options;</div><div class="line">    <span class="comment">// Options for indivudual tasks</span></div><div class="line">    vector&lt;Options&gt; task_opts;</div><div class="line">    <span class="comment">// Parse options from the command line</span></div><div class="line">    <span class="comment">// Used flag -task to separate options of individual tasks</span></div><div class="line">    parse_command_line(argc,argv, reader_options, <span class="stringliteral">&quot;task&quot;</span>, task_opts);</div><div class="line">    <span class="comment">// Create an instance of trajectory reader</span></div><div class="line">    Trajectory_reader engine(reader_options);</div><div class="line"></div><div class="line">    <span class="comment">// Add several tasks (with different parameters).</span></div><div class="line">    reader.add_task( <span class="keyword">new</span> My_task(task_opts[0]) );</div><div class="line">    reader.add_task( <span class="keyword">new</span> My_task(task_opts[1]) );</div><div class="line"></div><div class="line">    <span class="comment">// Start trajectory processing</span></div><div class="line">    engine.run();</div><div class="line">}</div></div><!-- fragment --><p>This program could be called with the following command line (see <a class="el" href="analysis.html#options">Processing command-line options</a> for details): </p><div class="fragment"><div class="line">./example -f some_file.pdb some_traj.xtc -b 10ps -e 2000fr -skip 2 -log 10 -task task1 -some_option1 val1 -task task2 -some_option2 val2</div></div><!-- fragment --><h2><a class="anchor" id="task_types"></a>
Serial and parallel tasks</h2>
<p>All analysis tasks in Pteros are subdivided into serial and parallel.</p>
<p>The objects of serial tasks exist as single instances, which run in their own thread of execution. The task is "serial" in the sence that <em>inside</em> the task code all operations are sequential and executed one by one in defined order. Trajectory_reader may run as many serial tasks as you want at the same time.</p>
<p>The parallel tasks behave differently. The Trajectory_reader may run only one parallel task and nothing else. The parallel task spawns as many instances of itself as there are cores in your processor. Each trajectory frame is dispatched to one of the instances only with no particular order. At the end all instances merge their results to the master instance, which is combining the results. Parallel tasks work much like parallel for loops over trajectory frames.</p>
<p>Regardless of the task type you have to override three methods: pre_process(), process_frame() and post_process(). For parallel tasks additional methods before_spawn() and collect_data() have to be overriden.</p>
<p>Tasks are created by the macro TASK_SERIAL or TASK_PARALLEL:</p>
<div class="fragment"><div class="line"><span class="comment">// Serial task</span></div><div class="line">TASK_SERIAL(My_serial_task)</div><div class="line">    <span class="keywordtype">void</span> pre_process()<span class="keyword"> override </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> process_frame(<span class="keyword">const</span> Frame_info&amp; info)<span class="keyword"> override </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> post_process(<span class="keyword">const</span> Frame_info&amp; info)<span class="keyword"> override </span>{ ...  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Parallel task</span></div><div class="line">TASK_PARALLEL(My_parallel_task)</div><div class="line">    <span class="keywordtype">void</span> pre_process()<span class="keyword"> override </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> process_frame(<span class="keyword">const</span> Frame_info&amp; info)<span class="keyword"> override </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> post_process(<span class="keyword">const</span> Frame_info&amp; info)<span class="keyword"> override </span>{ ...  }</div><div class="line">    <span class="keywordtype">void</span> before_spawn()<span class="keyword"> override </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> collect_data(<span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;Task_base&gt;&gt;&amp; tasks)<span class="keyword"> override </span>{ ... }</div><div class="line">};</div></div><!-- fragment --><p>The moments when these methods are called are different for serial and parallel tasks:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Serial task </th><th>Parallel task  </th></tr>
<tr>
<td>pre_process </td><td>Called by each task on the first valid trajectory frame </td><td>Called on the frame which is consumed first by particular task instance. It is not predictable which frame is this. This is a place to set up selections for this particular task instance. </td></tr>
<tr>
<td>process_frame </td><td>Called on each valid trajectory frame. For the first frame is called just after pre_process(). Frames are processed in order. </td><td>Called by task instances in parallel on different frames. Frames are dispatched to instances with no particular order on the "first come first served" basis. </td></tr>
<tr>
<td>post_process </td><td>Called after last valid trajectory frame for each task. </td><td>Called by each task instance after consuming last available frame for this instance. It is not predictable which frame is this. </td></tr>
<tr>
<td>collect_data </td><td>N/A </td><td>Called by master instance only when the trajectory is complete. All other instances are passed in tasks vector. The purpose is to merge local data of all instances together in the master instance for final processing. </td></tr>
<tr>
<td>before_spawn </td><td>N/A </td><td>Called by master task instance before spawning other instances and before consuming any frames. This is a place to process task options, set up jump remover, etc. <dl class="section warning"><dt>Warning</dt><dd>Do not set up any selections here! See below for details. </dd></dl>
</td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The reason of having separate collect_data() method is to keep the interface of serial and parallel task consistent otherwise.</dd></dl>
<h3><a class="anchor" id="par_select"></a>
Selections in parallel tasks</h3>
<p>Parallel tasks require additional attention when setting up selections. When "normal" serial task is executed it possesses an independent <a class="el" href="classpteros_1_1System.html" title="The system of atoms. ">System</a> in the member variable called 'system'. Any selections which are the members of your task class are created based on this system in the pre_process() method. All this is straightforward and easy to understand. When parallel task is executed the things become more complex. When multiple instances of your task class are spawned each of them will have its own 'system' variable. This means that any selection, which was made <em> before </em> spawning will be copyed to all task instances but they will still bind to the 'system' of the master instance! As a results you'll have a lot of fun trying to debug misterious errors and crashes. </p><dl class="section note"><dt>Note</dt><dd>To avoid this just remember the following rule: Never create any selections in before_spawn() method for parallel tasks! Create them in pre_process() only. before_spawn() is the place for initializing the stuff which is guaranteed to be the same for all task instances, like processing options.</dd></dl>
<h2><a class="anchor" id="options"></a>
Processing command-line options</h2>
<p>Trajectory_reader takes an <a class="el" href="classpteros_1_1Options.html" title="All options obtained from command line including nested options for tasks. ">Options</a> object, which provides mandatory built-in command-line options that specify which trajectory to read and which frames from it to accept. Default options are the following:</p>
<table class="doxtable">
<tr>
<th>Option flag</th><th>Meaning</th><th>Comment </th></tr>
<tr>
<td>-help </td><td>Show help on usage and options  </td><td><p class="starttd">Could be extended for custom options  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>-f  </td><td>List of files to read  </td><td><p class="starttd">Example: -f sturcture.pdb traj1.xtc traj2.xtc</p>
<p>The list may include</p><ul>
<li>Exactly one structure file (PDB or GRO). If not specified, topology PTTOP file must be given instead.</li>
<li>Topology PTTOP file (converted from Gromacs .tpr by tpr2pteros.py). If structure file is also present only topology is read from this file. If structure file is not present the coordinates are also read.</li>
<li>One or more trajectory files (TRR, XTC, TNG or DCD). TNG files also contain the structure, so if no structure file is given the structure is read from the first TNG file.</li>
</ul>
<p>Files may appear in any order, but trajectory files will be processed in the order of their appearance. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>-b  </td><td>Beginning of processing (starting frame or time) </td><td><p class="starttd">Default: 0 (fisrt frame of trajectory). <a class="el" href="analysis.html#suffix">Value suffixes</a> accepted. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>-e  </td><td>End of processing (end frame or time) </td><td><p class="starttd">Default: -1 (last frame of trajectory). <a class="el" href="analysis.html#suffix">Value suffixes</a> accepted. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>-t0  </td><td>Custom starting time  </td><td>Default: -1 (use value from the first frame). <a class="el" href="analysis.html#suffix">Value suffixes</a> accepted. Useful when trajectory does not contain time stamps or if the starting time is incorrect. <dl class="section warning"><dt>Warning</dt><dd>If this flag is set and <em>dt</em> is not given sets <em>dt</em> to 1.0!  </dd></dl>
</td></tr>
<tr>
<td>-dt  </td><td>Custom time step </td><td>Default: -1 (use value from trajectory). Useful when trajectory does not contain time stamps. <dl class="section warning"><dt>Warning</dt><dd>If this flag is set and <em>t0</em> is not given sets <em>t0</em> to 0!  </dd></dl>
</td></tr>
<tr>
<td>-log  </td><td>Prints logging information on each n-th processed frame </td><td><p class="starttd">Default: -1 (no logging). </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>-buffer  </td><td>Number of frames, which are kept in memory of Trajectory_reader </td><td><p class="starttd">Default: 10. You only need to decrease this if individual frames are <em>very</em> large. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>-task  </td><td>Name of the analysis task </td><td><p class="starttd">No default. Name of the task is used to load corresponding compiled analysis plugin or python plugin. <a class="el" href="classpteros_1_1Options.html" title="All options obtained from command line including nested options for tasks. ">Options</a>, which follow "-task name" are forwarded to the corresponding task only and will not be visible in other tasks or Trajectory_reader. Many tasks could be specified. </p>
<p class="endtd"></p>
</td></tr>
</table>
<h3><a class="anchor" id="suffix"></a>
Value suffixes</h3>
<p>Options -b, -e and -t0 could be specified with the following convenience suffixes:</p>
<table class="doxtable">
<tr>
<th>Suffix </th><th>Example </th><th>Meaning  </th></tr>
<tr>
<td>(no suffix)</td><td></td><td>value is in frames </td></tr>
<tr>
<td>fr </td><td>10fr </td><td>value is in frames </td></tr>
<tr>
<td>t </td><td>10t </td><td>value is time in picoseconds (value used as is) </td></tr>
<tr>
<td>ps </td><td>15ps </td><td>value is time in picoseconds (value used as is) </td></tr>
<tr>
<td>ns </td><td>100ns </td><td>value is time in nanoseconds (value multiplied by 10^3) </td></tr>
<tr>
<td>us </td><td>2us </td><td>value is time in microseconds (value multiplied by 10^6) </td></tr>
<tr>
<td>ms </td><td>4ms </td><td>value is time in milliseconds (value multiplied by 10^9) </td></tr>
</table>
<h2><a class="anchor" id="frame_info"></a>
Understanding frame metadata</h2>
<p>The process_frame() and post_process() methods of analysis tasks are called with Frame_info argument, which contains metadata of the currently processed frame:</p>
<table class="doxtable">
<tr>
<th>Property </th><th>Meaning  </th></tr>
<tr>
<td>absolute_frame </td><td>Counts <em>all</em> frames (either consumed or skipped) in trajectory starting from 0 </td></tr>
<tr>
<td>absolute_time </td><td>Current time stamp </td></tr>
<tr>
<td>valid_frame </td><td>Counts only valid frames (the frames, which fall into specified time and frame range) and are sent to processing. Starts from 0. </td></tr>
<tr>
<td>first_time </td><td>Time of the first processed valid frame </td></tr>
<tr>
<td>last_time </td><td>Time of the last processed valid frame. During the processing is set to absolute_time. Meaningfull for post-processing only. </td></tr>
<tr>
<td>first_frame </td><td>First processed valid frame (an absolute value) </td></tr>
<tr>
<td>last_frame </td><td>Last processed valid frame (an absolute value). During the processing is set to absolute_frame. Meaningfull for post-processing only. </td></tr>
</table>
<h2><a class="anchor" id="magic_vars"></a>
"Magic variables" in analysis tasks</h2>
<p>Each analysis task is derived from Task_base class under the hood and contains the following "magic variables":</p>
<table class="doxtable">
<tr>
<th>Variable </th><th>Meaning  </th></tr>
<tr>
<td>system </td><td>the <a class="el" href="classpteros_1_1System.html" title="The system of atoms. ">System</a> allocated locally for this task containg currently processing frame as frame #0. Changes in this system are local does not propagate to other serial tasks or instances of parallel tasks. </td></tr>
<tr>
<td>log </td><td>logger object, which is local for current task. Logger uses unique name formed by the name of task class and its id. </td></tr>
<tr>
<td>options </td><td><a class="el" href="classpteros_1_1Options.html" title="All options obtained from command line including nested options for tasks. ">Options</a> object with command-line options provided for this particular task. See <a class="el" href="analysis.html#options">Processing command-line options</a> for details. </td></tr>
<tr>
<td>jump_remover </td><td>Jump_remover object of the current task. See <a class="el" href="analysis.html#jump">Removing jumps over periodic boundaries</a> for details. </td></tr>
</table>
<h2><a class="anchor" id="jump"></a>
Removing jumps over periodic boundaries</h2>
<h1><a class="anchor" id="plugins"></a>
Analysis plugins</h1>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">User manual</a></li>
    <li class="footer">Generated on Thu Oct 14 2021 12:40:07 for Pteros by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
